{"version":3,"sources":["../App.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBO;AAjBP,qDAmBY;AAAU;AACC;AACH;AACH;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,oLACD;AAAA;AAAO;AACL;;AAAA,gDAIF;AAAA,0CAAgB;AAAA;AAAA;AAAA,6BAAhB;AAGC,yBAPC,MAEF;AAAA;AAAgB;AAHZ;AADH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;AAU5C;AACA;AACA;AACA;AAhBW,SAnBnB;;AAiBO;AAjBP,KAiBO;;AAoBA;AAAA;;AArCP,uCAwCiB,gCAxCjB;AAAA,2DAyC2B,8CAzC3B;;AA2CS;AA3CT,uCA2CS;AAAA;;AACD;AACA;AACA;AAHe;;AAAd;AAAA;AAAA,oCAKsB;AAAA;AAItB;AATA;;AAAA;AAAA;;AANF;;AAiBE;AAtDT,qCAsDS;AAAA;;AACD;AAEA;AACA;AACA;AACA;;AAGU,oDAEM;AAAU;AAAA;AAAV,sCAAU,oBAAV;AAA+B;AAC/B,kCAAwB,iDAAxB;AACA;AACA,gCAAQ,qDAAR;AAA2B,iBALjC;AAAA,sDAOM;AAAA;AACA;AAA2B;AARrB;AATT;;AAAZ;AAAA;AAAA,oCAqBG;AAAA;;AAAA,2BAAG,oBAAH,GACI,sBACiB,mCAAK,0BACW,0DADX,EAEN,8BAFM,CAAL,EADjB,CADJ,GASI,sBACiB,qCAAO;AACS;;AAChB;AACA;;AACM;;AAJC,sFAKN,oBAAH,GAAqB,uCAArB,GAA8B,wCALrB,EAMR,6CANQ;AAOnB,qBAPmB,EAAP,EADjB,CATJ;AAmBK;AAxCR;;AAAA;AAAA;;AAjBF;;AA2DE;AAhGT,iDAgGS;AAAA;;AACD,4BAA2E,WAAvC,oBAAmB;AAAA;AAAA,iBAAnB,gBAAuC,CAA3E;AACA;AACA,6BAAoB,kCAApB;AAHkB;;AAAjB;AAAA;AAAA,8CAMQ;AAAc,uDACF,qCAAO,oCAGP,qBAHO,EAIT,wCAJS,EAKR,6CALQ,EAMD,qBANC,CAAP,EADE;AAYnB,gCAAiB,CAAe,wBAAf,mBAAjB;AAZW;AANd;AAAA;AAAA,+CAqBG;AAAA,gCAAiB,iBAAuB;AAAA;AAAA,qBAAvB,CAAjB;AAAgE;AArBnE;AAAA;AAAA,iDAwBO;AAAA;;AAAc;AACP;;AACuC,yDAA/B,mBAAkB;AAAA;AAAA,yBAAlB,cAA+B;;AAFhC;AAIjB,qBAJiB;;AAKP;;AACX;AANe;AAxBlB;;AAAA;AAAA;;AA3DF;;AA6FE;AAlIT,qDAkIS;AAAA;;AACD,kCAAqF,WAAhD,oBAAmB;AAAA;AAAA,iBAAnB,WAAgD,CAArF;AACA;AAFsB;;AAArB;AAAA;AAAA,8CAMG;AAAA;AACA;AAAuC;AAP1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AA7FF;;AArCP,6CAiJQ;AAAA;AAAA,2MAKsB;AAAA;;AAAA,+BAGE;AAAA;AAAK;AACT,qCACI;AAAA;AAAW,yBADf;AADI;AAAE;AAHH,aALvB;AAAA,SAjJR;AAAA,+BAgKa,gEAhKb;AAiKI;AACA;AAlKJ,iCAmKc,sCAnKd;AAqCO;AArCP,KAqCO","file":"App.js","sourceRoot":"C:/dev/Pricer/Pricer.Fabled/CompiledJs","sourcesContent":["ï»¿namespace Pricer.Fabled\r\n\r\nopen System\r\nopen Pricer.Core\r\nopen Fable.Core\r\nopen Fable.Import\r\nopen Fable.Core.JsInterop\r\nopen System.Text.RegularExpressions\r\n\r\n[<Erase>]\r\nmodule Lib =\r\n    let [<Global>] Vue: obj = failwith \"JS only\"\r\n    let [<Global>] Router: obj = failwith \"JS only\"\r\n\r\n\r\n// This helper uses JS reflection to convert a class instancegfa\r\n// to the options' format required by Vue\r\nmodule VueHelper =\r\n    let createFromObj(data: obj, extraOpts: obj) =\r\n        let methods = obj()\r\n        let computed = obj()\r\n        let proto = JS.Object.getPrototypeOf data\r\n        for k in JS.Object.getOwnPropertyNames proto do\r\n            let prop = JS.Object.getOwnPropertyDescriptor(proto, k)\r\n            match prop.value with\r\n            | Some f ->\r\n                methods?(k) <- f\r\n            | None ->\r\n                computed?(k) <- JsInterop.createObj [\r\n                    \"get\" ==> prop?get\r\n                    \"set\" ==> prop?set\r\n                ]\r\n        extraOpts?data <- data\r\n        extraOpts?computed <- computed\r\n        extraOpts?methods <- methods\r\n        JsInterop.createNew Lib.Vue extraOpts\r\n\r\nmodule Main =\r\n    \r\n    \r\n    let pricer = new SimplePricer()\r\n    let payoffsGenerator = new PayoffsGenerator(pricer)\r\n\r\n    type StockViewModel(s:StockInfo) = \r\n        let mutable rate = s.Rate\r\n        let mutable volatility = s.Volatility\r\n        let mutable currentPrice = s.CurrentPrice\r\n\r\n        member __.buildStock = {\r\n            Rate = rate\r\n            Volatility = volatility\r\n            CurrentPrice = currentPrice\r\n        }\r\n\r\n    type LegViewModel(l:Leg) = \r\n        let mutable leg = l\r\n        // All these things are strings, because they come from text fields later and vuejs will give us string :(\r\n        let mutable strike = \"0.0\"\r\n        let mutable expiry = \"test\"\r\n        let mutable kind = \"Option\"\r\n        let mutable direction = \"Buy\"       \r\n\r\n        do \r\n            match l.Definition with\r\n                    | Option opt -> \r\n                        strike <- opt.Strike.ToString()\r\n                        expiry <- opt.Expiry |> Tools.toDate\r\n                        direction <- opt.BuyVsSell\r\n                        kind <- opt.Kind.ToString()\r\n                    | Cash cash -> \r\n                        kind <- \"Cash\"\r\n                        direction <- cash.BuyVsSell\r\n                    | _ -> ()\r\n        \r\n        member __.getLeg = \r\n            if kind = \"Cash\" then \r\n                {\r\n                    Definition = Cash { \r\n                        Direction = direction |> Transforms.stringToDirection\r\n                        Price = float strike\r\n                    }\r\n                    Pricing = None\r\n                }\r\n            else\r\n                {\r\n                    Definition = Option { \r\n                        Direction = direction |> Transforms.stringToDirection\r\n                        Expiry = Tools.parseDate expiry\r\n                        Strike = float strike\r\n                        PurchaseDate = DateTime.Now\r\n                        Kind = if kind = \"Put\" then Put else Call\r\n                        Style = European\r\n                    }\r\n                    Pricing = None\r\n                }\r\n\r\n    type StrategyViewModel(strategy) =\r\n        let mutable legs = strategy.Legs |> List.map (fun l -> LegViewModel(l)) |> Array.ofList\r\n        let mutable name = strategy.Name\r\n        let mutable stock = new StockViewModel(strategy.Stock)\r\n        \r\n        member __.addLeg(event) = \r\n            let  newLeg: Leg = {\r\n                Definition = Option {\r\n                    Direction = 1.0\r\n                    Strike = 100.0\r\n                    Expiry = DateTime.Now\r\n                    Kind = Call\r\n                    Style = European\r\n                    PurchaseDate = DateTime.Now\r\n                }\r\n                Pricing = None\r\n            }\r\n\r\n            legs <- (legs |> Array.append [|new LegViewModel(newLeg)|])\r\n        \r\n        member __.removeLeg(leg:LegViewModel) =\r\n            legs <- (legs |> Array.filter (fun l -> l.getLeg <> leg.getLeg))\r\n\r\n        member __.generatePayoff() = \r\n            let newStrategy = {\r\n                Name = name\r\n                Legs = legs |> Seq.map (fun l -> l.getLeg) |> List.ofSeq\r\n                Stock = stock.buildStock\r\n            }\r\n            let data = payoffsGenerator.getStrategyData newStrategy\r\n            Charting.drawPayoff data\r\n\r\n\r\n\r\n    type StrategyListViewModel(examples) = \r\n        let mutable strategies = examples |> List.map (fun s -> new StrategyViewModel(s)) |> Array.ofList\r\n        let mutable selectedStrategy: StrategyViewModel option = None\r\n\r\n        member __.allStrategies = strategies\r\n        member __.select strat = \r\n            selectedStrategy <- Some strat\r\n            selectedStrategy.Value.generatePayoff()\r\n\r\n        member __.strategy = selectedStrategy\r\n        \r\n    type Directives =\r\n        abstract ``todo-focus``: obj option -> unit\r\n            \r\n    let extraOpts =\r\n        createObj [\r\n            \"el\" ==> \".payoffapp\"           \r\n            \"directives\" ==> {\r\n                new Directives with\r\n                    member this.``todo-focus`` x =\r\n                        match x with\r\n                        | None -> ()\r\n                        | Some _ ->\r\n                            let el = this?el\r\n                            Lib.Vue?nextTick$(fun () ->\r\n                                el?focus$() |> ignore)\r\n                            |> ignore\r\n            } \r\n        ]\r\n\r\n    let vm = StrategyListViewModel(StrategiesExamples.exampleStrategies)\r\n    vm.select vm.allStrategies.[4]\r\n    vm.strategy.Value.generatePayoff()\r\n    let app = VueHelper.createFromObj(vm, extraOpts)"]}