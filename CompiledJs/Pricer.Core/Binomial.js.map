{"version":3,"sources":["../../../Pricer.Core/Binomial.fs"],"names":[],"mappings":"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","file":"Binomial.js","sourceRoot":"C:/dev/Pricer/Pricer.Fabled/CompiledJs/Pricer.Core","sourcesContent":["ï»¿namespace Pricer.Core\r\n\r\ntype Implementation =\r\n    | Functional \r\n    | Imperative\r\n    | FunctionalFast\r\n\r\n//this type holds the configuration for binomial pricing model\r\ntype BinomialPricing = {\r\n    Periods : int\r\n    Down : float\r\n    Up :float\r\n    PUp:float\r\n    PDown:float\r\n    Option: OptionLeg\r\n    Rate:float\r\n    Ref:float\r\n}\r\n\r\nmodule Binomial =\r\n    \r\n    let binomialPrice (ref:float) (strike:float) (rate:float) (up:float) =\r\n        let down = 1.0/up\r\n        let q = (exp (-rate)-down) / (up - down) \r\n        let cu = max 0.0 (up*ref-strike)\r\n        let cd = max 0.0 (down*ref-strike)\r\n        let call = exp(-rate) * (q*cu + (1.0-q)*cd)\r\n        call\r\n\r\n    let binomialPricing (pricing:BinomialPricing) =\r\n        let prices = Array.zeroCreate pricing.Periods\r\n        let optionValue = \r\n            match pricing.Option.Kind with\r\n                    | Call -> fun i -> max 0.0 (prices.[i] - pricing.Option.Strike)\r\n                    | Put -> fun i -> max 0.0 (pricing.Option.Strike - prices.[i])\r\n                                 \r\n        prices.[0] <- pricing.Ref*(pricing.Down**(float pricing.Periods))\r\n        let oValues = Array.zeroCreate pricing.Periods\r\n        oValues.[0]<- optionValue 0\r\n        for i in 1 ..pricing.Periods-1 do\r\n            prices.[i] <- prices.[i-1]*pricing.Up*pricing.Up\r\n            oValues.[i]<- optionValue i\r\n\r\n        let counter = pricing.Periods-2\r\n        for step = counter downto 0 do\r\n            for j in 0 .. step do\r\n                oValues.[j] <- (pricing.PUp*oValues.[j+1]+pricing.PDown*oValues.[j])*(1.0/pricing.Rate)\r\n                if pricing.Option.Style = American then\r\n                    prices.[j] <- pricing.Down*prices.[j+1]\r\n                    oValues.[j] <- max oValues.[j] (optionValue j)\r\n        let delta = (oValues.[1] - oValues.[1]) / (pricing.Ref*pricing.Up - pricing.Ref*pricing.Down)\r\n        {\r\n            Premium = oValues.[0]\r\n            Delta = delta\r\n        }\r\n\r\n    \r\n    let generateEndNodePrices (ref:float) (up:float) (periods:int) optionVal =\r\n        let down = 1.0 / up \r\n        let lowestStock = ref*(down**(float periods))\r\n        let first = lowestStock,optionVal lowestStock\r\n        let values = Seq.unfold (fun (stock,der)-> \r\n            let stock' = stock*up*up\r\n            let der' = optionVal stock'\r\n            Some ((stock,der),(stock', der'))) first\r\n        values |> Seq.take periods |> List.ofSeq\r\n\r\n    let step pricing optionVal (prices:(float*float) list) =\r\n        prices \r\n            |> Seq.pairwise \r\n            |> Seq.map (fun ((sDown,dDown),(sUp,dUp)) -> \r\n                let derValue = (pricing.PUp*dUp+pricing.PDown*dDown)*(1.0/pricing.Rate)\r\n                let stockValue = sUp*pricing.Down\r\n                let der' = match pricing.Option.Style with\r\n                                    | American -> \r\n                                        let prematureExValue = optionVal stockValue\r\n                                        max derValue prematureExValue\r\n                                    | European -> derValue\r\n                stockValue,der')\r\n            |> List.ofSeq\r\n\r\n    let binomialPricingFunc (pricing:BinomialPricing) =\r\n        let optionValue = BasicOptions.optionValue pricing.Option\r\n        let prices = generateEndNodePrices pricing.Ref pricing.Up pricing.Periods optionValue\r\n        \r\n        let reductionStep = step pricing optionValue\r\n        let rec reducePrices prices =\r\n            match prices with\r\n                    | [(stock,der)] -> der\r\n                    | prs -> reducePrices (reductionStep prs)\r\n        //TODO: calculate the correct delta in this functional implementation    \r\n        let premium = reducePrices prices\r\n        {\r\n            Premium = premium\r\n            Delta = 1.0\r\n        }\r\n\r\n    let generateEndNodePricesFast (ref:float) (up:float) (periods:int) optionVal =\r\n        let down = 1.0 / up \r\n        let lowestStock = ref*(down**(float periods))\r\n        let first = lowestStock,optionVal lowestStock\r\n        let values = Seq.unfold (fun (stock,der)-> \r\n            let stock' = stock*up*up\r\n            let der' = optionVal stock'\r\n            Some ((stock,der),(stock', der'))) first\r\n        values |> Seq.take periods |> Seq.toArray\r\n\r\n    let stepFast pricing optionVal (prices:(float*float) []) =\r\n        prices \r\n            |> Array.pairwise \r\n            |> Array.map (fun ((sDown,dDown),(sUp,dUp)) -> \r\n                let derValue = (pricing.PUp*dUp+pricing.PDown*dDown)*(1.0/pricing.Rate)\r\n                let stockValue = sUp*pricing.Down\r\n                let der' = match pricing.Option.Style with\r\n                                    | American -> \r\n                                        let prematureExValue = optionVal stockValue\r\n                                        max derValue prematureExValue\r\n                                    | European -> derValue\r\n                stockValue,der')\r\n            \r\n\r\n    let binomialPricingFuncFast (pricing:BinomialPricing) =\r\n        let optionValue = BasicOptions.optionValue pricing.Option\r\n        let prices = generateEndNodePricesFast pricing.Ref pricing.Up pricing.Periods optionValue\r\n        \r\n        let reductionStep = stepFast pricing optionValue\r\n        let rec reducePrices prices =\r\n            match prices with\r\n                    | [|(stock,der)|] -> der\r\n                    | prs -> reducePrices (reductionStep prs)\r\n        //TODO: calculate the correct delta in this functional implementation    \r\n        let premium = reducePrices prices\r\n        {\r\n            Premium = premium\r\n            Delta = 1.0\r\n        }\r\n\r\n    let binomial (stock:StockInfo) (option:OptionLeg) (steps:int) implementation = \r\n\r\n        //we need to construct the binomial pricing model, using the CRR (Cox, Ross and Rubinstein)\r\n        //the original model is composed of 3 parameters p,u,d. \r\n        //u - up probability, d - down probability. p is the technical probability\r\n        //here we have PUp and PDown, for further simplifacation of the calculations\r\n        let deltaT = option.TimeToExpiry/float steps\r\n        let up = exp(stock.Volatility*sqrt deltaT)\r\n        let down = 1.0/up\r\n        let R = exp (stock.Rate*deltaT)\r\n        let p_up = (R-down)/(up-down)\r\n        let p_down = 1.0 - p_up\r\n\r\n        let pricing = {\r\n            Periods = steps\r\n            Up = up\r\n            Down = down\r\n            PUp = p_up\r\n            PDown = p_down\r\n            Rate = R\r\n            Option = option\r\n            Ref = stock.CurrentPrice\r\n        }\r\n        \r\n        match implementation with\r\n            | Imperative -> binomialPricing pricing\r\n            | Functional -> binomialPricingFunc pricing\r\n            | FunctionalFast -> binomialPricingFuncFast pricing"]}