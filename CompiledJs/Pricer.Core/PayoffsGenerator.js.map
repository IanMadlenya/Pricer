{"version":3,"sources":["../../../Pricer.Core/PayoffsGenerator.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,0CAIK;AAAA;;AAAkB;AAAF;;;;mDAGP;AAAA;;AAAA,0DAEoB;AAAA;AAAA;AAAA;AAAA,kDAFpB,2CAG2B;AAAA;AAAA;AAAA;AAAA,kDAH3B,GACgB,+CADhB;AAAc;;;2DAOpB;AAAA,uBAAoB,qCAApB,GAAqC,sBAArC,GAEQ;AAA2B,sDACrB;AAAA;AAAA,qBADqB;;AAMrB,oCAAgB;AAAA;AAAA,+BAAhB;;AACA,oCAAgB;AAAA;AAAA,+BAAhB;;AAEN;AAAA,oFACA;AAAA,yDAAmB;AAAA;AAAA,uCAAnB,EACA;AAAA;AAAA,8BADA;AAAA,0BADA;AAAA;AATO,iBAAP,EAFR;AAcK;;;sEAEC;AAAA,+CAGoB,2BAAuB,mFAAvB,CAHpB,gCAI2B,2BAAyB,uEAAzB,CAJ3B,GAEgB,2BAAqB,gCAArB,CAFhB;AAAG;;;sDAQL;AAAA;;AACM;AAAA,iDAEQ;AAAA;AAAA;AAAA;AAAA,0CAFR;AAAA;;AAK2B,uDAC7B;AAAU;;AACE;AAAA;AAAA;AAAmC,qBAAnC;;AACO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFnB;AAAO,iBADsB;;AAOb;;AACW,wDAA6B;AAAA;AAAA,iBAA7B;;AAE7B,iCAEM;AAAA;AAAQ;;AAEoB;AAAA,kDACd,mBAAqB;AAAA,6DAAC;AAAA;AAAA,4DAA0D,8BAA1D;AAAA;AAAA,kCAAD;AAAA,6BAArB,QADc;AAAA;;AAIJ,8DACxB;AAAA,yDAAC;AAAA;AAAA,wDAA0E,qBAA+B;AAAA;AAAA,qCAA/B,gBAA1E;AAAA;AAAA,8BAAD;AAAA,yBADwB;;AAI5B;AAAA;AAAA;AAVI;;AAAA;AAAK,iBAFX,MAcM;AAA4B;AAAA,8CACvB,sBAAC;AAAA;AAAA,oDAA0D,2BAA1D;AAAA;AAAA,0BAAD,CADuB;AAAA;;AAIb,8DAAC;AAAA;AAAA,gDAA0E,qBAA+B;AAAA;AAAA,6BAA/B,gBAA1E;AAAA;AAAA,sBAAD;;AAEnB;AANY;AA9BC","file":"PayoffsGenerator.js","sourceRoot":"C:/dev/Pricer/Pricer.Fabled/CompiledJs/Pricer.Core","sourcesContent":["ï»¿namespace Pricer.Core\r\n\r\nopen System\r\n\r\ntype PayoffsGenerator (pricer:IPricer) =\r\n\r\n    member this.legPricing stock leg =\r\n        match leg.Definition with\r\n            | Cash cashLeg -> pricer.priceCash cashLeg\r\n            | Option optionLeg -> pricer.priceOption stock optionLeg\r\n            | Convertible convertible -> pricer.priceConvert stock convertible\r\n\r\n    //only some x points are interesting - precisely all the strikes\r\n    member this.getInterestingPoints strategy =\r\n        if strategy.Legs |> Seq.isEmpty then Seq.empty\r\n        else\r\n            let strikes = strategy.Legs |> List.map (fun leg ->\r\n                match leg.Definition with\r\n                    | Cash cash -> cash.Price\r\n                    | Option option -> option.Strike\r\n                    | Convertible convertible -> convertible.ReferencePrice \r\n            )\r\n            let min = 0.5*(strikes |> Seq.min)\r\n            let max = 1.5*(strikes |> Seq.max)\r\n            seq {\r\n                yield min\r\n                yield! (strikes |> Seq.sort)\r\n                yield max\r\n            }\r\n    member this.legPayoff leg pricing (year:int) stockPrice =\r\n        match leg with\r\n\r\n            | Cash cashLeg -> cashLeg.Direction * (stockPrice - cashLeg.Price)\r\n            | Option optionLeg -> optionLeg.Direction * (BasicOptions.optionValue optionLeg stockPrice - pricing.Premium)\r\n            | Convertible convertible -> convertible.Direction * (float year * convertible.Coupon * convertible.FaceValue - pricing.Premium)\r\n\r\n\r\n    member this.getStrategyData (strategy:Strategy) =\r\n        let getLegPricing leg =\r\n            match leg.Pricing with\r\n                | Some pricing -> pricing\r\n                | None -> this.legPricing strategy.Stock leg\r\n\r\n        \r\n        let payOffsPerLeg = strategy.Legs |> Seq.map (fun leg ->\r\n            let pricing = getLegPricing leg\r\n            let pricedLeg = { leg with Pricing = Some pricing }\r\n            let payoffCalculator = this.legPayoff leg.Definition pricing   \r\n            pricedLeg, payoffCalculator\r\n        )\r\n\r\n        let interestingPoints = this.getInterestingPoints strategy\r\n        let hasConverts = strategy.Legs |> Seq.exists (fun leg -> match leg.Definition with | Convertible _ -> true | _ -> false)\r\n        \r\n        match hasConverts with\r\n            | true -> \r\n                let years = [1;2;3]\r\n\r\n                let legsData = payOffsPerLeg |> Seq.map (fun (leg,payOff) -> \r\n                    leg, years |> Seq.map (fun year -> [for stockPrice in interestingPoints  do yield stockPrice, payOff year stockPrice])\r\n                )\r\n\r\n                let strategyData = years |> Seq.map (fun year -> \r\n                    [for stockPrice in interestingPoints do yield stockPrice, payOffsPerLeg |> Seq.sumBy (fun (leg,payOff) -> payOff year stockPrice)]\r\n                )\r\n\r\n                MultiYear strategyData\r\n            | false -> \r\n                let legsData = payOffsPerLeg |> Seq.map (fun (leg,payOff) -> \r\n                    leg, [for stockPrice in interestingPoints  do yield stockPrice, payOff 1 stockPrice]\r\n                )\r\n\r\n                let strategyData = [for stockPrice in interestingPoints do yield stockPrice, payOffsPerLeg |> Seq.sumBy (fun (leg,payOff) -> payOff 1 stockPrice)]\r\n                \r\n                SingleYear (strategyData,legsData)"]}