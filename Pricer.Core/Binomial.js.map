{"version":3,"sources":["../../Pricer.Core/Binomial.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAEK,kDAFL;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,KAEK;;AAKA,oDAPL;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAOK;;AAWE;AAEC,qDACI;AAAA;AAAA,0BAAO,MAAP,MACI,CAAC,SAAK,KAAL,QAAD,KAAsB,SAAtB,CADJ,OAEK,IAAS,iBAFd,OAEc,iBAFd,OAGK,IAAS,mBAHd,OAGc,mBAHd,SAIO,SAAI,KAAJ,KAAc,SAAO,CAAC,KAAD,MAArB,CAJP;AAAI,SADR;;AAQA,yDACI;AAAA;AAAA;;AAEM;AAAA;AAAA,yFAEoB;AAAA,mCAAS,iCAAT,OAAS,iCAAT;AAA4C,qBAFhE,GACqB;AAAA,mCAAS,iCAAT,OAAS,iCAAT;AAA4C,qBADjE;AAAmB,iBAAnB;;AAIV,4BAAc,cAAa,uCAA3B;AANI;AAQJ,6BAAc,cAAd;;AACA,qCAAa,mBAAb,OACI;AAAA,gCAAc,OAAQ,KAAR,2BAAd;AACA,iCAAc,cAAd;AAA2B;;AAEjB;;AACd,4DACI;AAAA,oDACI;AAAA,qCAAe,CAAC,sBAAqB,KAArB,IAA0B,0BAA3B,KAAuD,gBAAvD,CAAf;AACG,wEAAuB,yCAAvB,OAAH,IACI,YAAc,sBAAqB,KAArB,CADlB,EAEI,aAAe,aAAiB,cAAhC,gBAAgC,cAFpC;AAEkD;AAAA;;AAC9C,6BAAC,uBAAD,KAA+B,2BAAyB,0BAAxD;AAEE;AAtBV,uBAqBJ,yCArBI;AAAA;AAAM,SADV;;AA4BA,qEACI;AAAA;AAAA,0BAAO,MAAP,gBACc,MAAK,uBADnB,wBAEoB,sBAFpB,YAGS,sBAAiB;AAAA;AAAA,0EACb,eADa,SAEf,iBAFe;AAAK,aAAtB,QAHT,EAOJ,sBAAU;AAAA;AAAgB,aAA1B,SAPI;AAAI,SADR;;AAUA,mCACA;AAAA,4DAEsB;AAAA;;AAAA,kJACC,CAAC,oBAAgB,qBAAjB,KAAuC,gBAAvC,CADD,eAEG,kBAFH,6CAGG,gEAE8B,qBAF9B,EAGO,2BAHP,+BAHH;AAAW,aAFjC;AAWiB,SAZjB;;AAcA,iEACI;AAAA;AAAA,iCAAc;AAAA;AAAA;AAAA;AAAuC,iBAAvC;AAAuC,aAAvC,EAAd,WACS,4EADT,kBAGgB;AAAA;AAAwB,aAHxC,iBAKM;AAAA;AAAA,kCAEW;AAAA,wCAAc,kBAAd;AAAgC,iBAF3C;AAAM,aALZ,YASU,oBATV,EAUJ,qCAVI;AAAW,SADf;;AAgBA,2CAMI;AAAA;AAAA,4BAAS,2BAAT,OACK,SAAI,mBAAiB,iBAArB,CADL,SAEO,MAFP,MAGI,SAAK,mBAAL,CAHJ,SAIO,CAAC,QAAD,KAAU,SAAV,CAJP,WAKS,QALT,YAOU,iFAPV,EAkBE,uCAEc,4BAFd,GACc,wBAnBhB;AAAM,SANV;;AA9ED;AA8ES,KA9ET","file":"Binomial.js","sourcesContent":["ï»¿namespace Pricer.Core\r\n\r\ntype Implementation =\r\n    | Functional \r\n    | Imperative\r\n\r\n//this type holds the configuration for binomial pricing model\r\ntype BinomialPricing = {\r\n    Periods : int\r\n    Down : float\r\n    Up :float\r\n    PUp:float\r\n    PDown:float\r\n    Option: OptionLeg\r\n    Rate:float\r\n    Ref:float\r\n}\r\n\r\nmodule Binomial =\r\n    \r\n    let binomialPrice (ref:float) (strike:float) (rate:float) (up:float) =\r\n        let down = 1.0/up\r\n        let q = (exp (-rate)-down) / (up - down) \r\n        let cu = max 0.0 (up*ref-strike)\r\n        let cd = max 0.0 (down*ref-strike)\r\n        let call = exp(-rate) * (q*cu + (1.0-q)*cd)\r\n        call\r\n\r\n    let binomialPricing (pricing:BinomialPricing) =\r\n        let prices = Array.zeroCreate pricing.Periods\r\n        let optionValue = \r\n            match pricing.Option.Kind with\r\n                    | Call -> fun i -> max 0.0 (prices.[i] - pricing.Option.Strike)\r\n                    | Put -> fun i -> max 0.0 (pricing.Option.Strike - prices.[i])\r\n                                 \r\n        prices.[0] <- pricing.Ref*(pricing.Down**(float pricing.Periods))\r\n        let oValues = Array.zeroCreate pricing.Periods\r\n        oValues.[0]<- optionValue 0\r\n        for i in 1 ..pricing.Periods-1 do\r\n            prices.[i] <- prices.[i-1]*pricing.Up*pricing.Up\r\n            oValues.[i]<- optionValue i\r\n\r\n        let counter = pricing.Periods-2\r\n        for step = counter downto 0 do\r\n            for j in 0 .. step do\r\n                oValues.[j] <- (pricing.PUp*oValues.[j+1]+pricing.PDown*oValues.[j])*(1.0/pricing.Rate)\r\n                if pricing.Option.Style = American then\r\n                    prices.[j] <- pricing.Down*prices.[j+1]\r\n                    oValues.[j] <- max oValues.[j] (optionValue j)\r\n        let delta = (oValues.[1] - oValues.[1]) / (pricing.Ref*pricing.Up - pricing.Ref*pricing.Down)\r\n        {\r\n            Premium = oValues.[0]\r\n            Delta = delta\r\n        }\r\n\r\n    \r\n    let generateEndNodePrices (ref:float) (up:float) (periods:int) optionVal =\r\n        let down = 1.0 / up \r\n        let lowestStock = ref*(down**(float periods))\r\n        let first = lowestStock,optionVal lowestStock\r\n        let values = Seq.unfold (fun (stock,der)-> \r\n            let stock' = stock*up*up\r\n            let der' = optionVal stock'\r\n            Some ((stock,der),(stock', der'))) first\r\n        values |> Seq.take periods |> List.ofSeq\r\n\r\n    let step pricing optionVal (prices:(float*float) list) =\r\n        prices \r\n            |> Seq.pairwise \r\n            |> Seq.map (fun ((sDown,dDown),(sUp,dUp)) -> \r\n                let derValue = (pricing.PUp*dUp+pricing.PDown*dDown)*(1.0/pricing.Rate)\r\n                let stockValue = sUp*pricing.Down\r\n                let der' = match pricing.Option.Style with\r\n                                    | American -> \r\n                                        let prematureExValue = optionVal stockValue\r\n                                        max derValue prematureExValue\r\n                                    | European -> derValue\r\n                stockValue,der')\r\n            |> List.ofSeq\r\n\r\n    let binomialPricingFunc (pricing:BinomialPricing) =\r\n        let optionValue = BasicOptions.optionValue pricing.Option\r\n        let prices = generateEndNodePrices pricing.Ref pricing.Up pricing.Periods optionValue\r\n        \r\n        let reductionStep = step pricing optionValue\r\n        let rec reducePrices prices =\r\n            match prices with\r\n                    | [(stock,der)] -> der\r\n                    | prs -> reducePrices (reductionStep prs)\r\n        //TODO: calculate the correct delta in this functional implementation    \r\n        let premium = reducePrices prices\r\n        {\r\n            Premium = premium\r\n            Delta = 1.0\r\n        }\r\n\r\n    let binomial (stock:StockInfo) (option:OptionLeg) (steps:int) implementation = \r\n\r\n        //we need to construct the binomial pricing model, using the CRR (Cox, Ross and Rubinstein)\r\n        //the original model is composed of 3 parameters p,u,d. \r\n        //u - up probability, d - down probability. p is the technical probability\r\n        //here we have PUp and PDown, for further simplifacation of the calculations\r\n        let deltaT = option.TimeToExpiry/float steps\r\n        let up = exp(stock.Volatility*sqrt deltaT)\r\n        let down = 1.0/up\r\n        let R = exp (stock.Rate*deltaT)\r\n        let p_up = (R-down)/(up-down)\r\n        let p_down = 1.0 - p_up\r\n\r\n        let pricing = {\r\n            Periods = steps\r\n            Up = up\r\n            Down = down\r\n            PUp = p_up\r\n            PDown = p_down\r\n            Rate = R\r\n            Option = option\r\n            Ref = stock.CurrentPrice\r\n        }\r\n        \r\n        match implementation with\r\n            | Imperative -> binomialPricing pricing\r\n            | Functional -> binomialPricingFunc pricing"]}