{"version":3,"sources":["../../Pricer.Core/PayoffsGenerator.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIK;AAAA;AAAA;;AAAkB;AAAF;;AAAhB;AAAA;AAAA,mDAGS;AAAA;;AAAA;AAAA;AAAA,uFAEoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwB,qCAAxB;AAAwB,iCAAxB;AAAwB,6BAAxB;AAAwB,yBAAxB;AAAkC,qBAAlC,EAFpB,uCAG2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyB,qCAAzB;AAAyB,iCAAzB;AAAyB,6BAAzB;AAAyB,yBAAzB;AAAqC,qBAArC,EAH3B,oCACgB,+BADhB;AAAc,iBAAd;AAAc;AAHvB;AAAA;AAAA,2DAUG;AAAA;AAAA,uBAAG,qCAAH,GAAqC,sBAArC,cAEkB,oBACJ;AAAA;AAAA;AAAc,iBADV,gBAFlB,QAQc,MAAK,2BARnB,QASc,MAAK,2BATnB,EAWQ;AAAA,gFACA;AAAA,mFACA;AAAA;AAAS,yBAAT,CADA;AAA4B,qBAA5B,CADA;AAAS,iBAAT,CAXR;AAcK;AAxBR;AAAA;AAAA,sEA0BS;AAAA;AAAA,2EAGoB,uBAAuB,+EAAvB,CAHpB,+DAI2B,yBAAyB,mEAAzB,CAJ3B,8BAEgB,qBAAqB,0BAArB,CAFhB;AAAG;AA1BZ;AAAA;AAAA,sDAkCO;AAAA;oBAAA;oBAAA;oBAAA;oBAAA;oBAAA;oBAAA;oBAAA;;AAAA,uCACM;AAAA;AAAA;AAAA,8EAEQ;AAAA;AAAA;AAA8B,6BAA9B;AAA8B,yBAA9B,qBAFR;AAAW,qBAAX;AAAW,iBADjB,kBAMgB,mBACZ;AAAA;AAAA,qCAAU,kBAAV,kCACY,8CADZ,sBAEmB;AAAA;AAAA;AAAA;AAAA;AAA6B,iCAA7B;AAA6B,6BAA7B;AAA6B,yBAA7B;AAA6B,qBAA7B,yBAFnB;AAAO,iBADK,gBANhB,sBAaoB,mCAbpB,gBAcc,sBAA8C;AAAA;AAAA;AAAc,iBAA5D,gBAdd,EAgBE,uBAEc,kCAFd,aAIiB,mBAA+B;AAAA;AAAA,4EACrC,mBAA8B;AAAA,qDAAC;AAAA;AAAA,oDAA0D,wBAA1D;AAAA;AAAgF,yBAAhF,CAAD;AAAkF,qBAAhH,QADqC;AAAG,iBAAlC,gBAJjB,iBAQqB,mBACf;AAAA,iDAAC;AAAA;AAAA,gDAAyD,qBAAiC;AAAA;AAAA;AAAA,sFAAe,wBAAf;AAAG,iCAAH;AAAG,6BAApC,gBAAzD;AAAA;AAAgI,qBAAhI,CAAD;AAAkI,iBADnH,QARrB,EAYE,yDAZF,gBAciB,mBAA+B;AAAA;AAAA,4EACrC,sBAAC;AAAA;AAAA,gDAA0D,qBAA1D;AAAA;AAA6E,qBAA7E,CAAD,CADqC;AAAG,iBAAlC,gBAdjB,iBAkBqB,sBAAC;AAAA;AAAA,4CAAyD,qBAAiC;AAAA;AAAA;AAAA,kFAAe,qBAAf;AAAG,6BAAH;AAAG,yBAApC,gBAAzD;AAAA;AAA6H,iBAA7H,CAAD,CAlBrB,EAoBE,oEApBF,CAhBF;AAAiB;AAlCxB;;AAAA;AAAA","file":"PayoffsGenerator.js","sourcesContent":["ï»¿namespace Pricer.Core\r\n\r\nopen System\r\n\r\ntype PayoffsGenerator (pricer:IPricer) =\r\n\r\n    member this.legPricing stock leg =\r\n        match leg.Definition with\r\n            | Cash cashLeg -> pricer.priceCash cashLeg\r\n            | Option optionLeg -> pricer.priceOption stock optionLeg\r\n            | Convertible convertible -> pricer.priceConvert stock convertible\r\n\r\n    //only some x points are interesting - precisely all the strikes\r\n    member this.getInterestingPoints strategy =\r\n        if strategy.Legs |> Seq.isEmpty then Seq.empty\r\n        else\r\n            let strikes = strategy.Legs |> List.map (fun leg ->\r\n                match leg.Definition with\r\n                    | Cash cash -> cash.Price\r\n                    | Option option -> option.Strike\r\n                    | Convertible convertible -> convertible.ReferencePrice \r\n            )\r\n            let min = 0.5*(strikes |> Seq.min)\r\n            let max = 1.5*(strikes |> Seq.max)\r\n            seq {\r\n                yield min\r\n                yield! (strikes |> Seq.sort)\r\n                yield max\r\n            }\r\n    member this.legPayoff leg pricing (year:int) stockPrice =\r\n        match leg with\r\n\r\n            | Cash cashLeg -> cashLeg.Direction * (stockPrice - cashLeg.Price)\r\n            | Option optionLeg -> optionLeg.Direction * (BasicOptions.optionValue optionLeg stockPrice - pricing.Premium)\r\n            | Convertible convertible -> convertible.Direction * (float year * convertible.Coupon * convertible.FaceValue - pricing.Premium)\r\n\r\n\r\n    member this.getStrategyData (strategy:Strategy) =\r\n        let getLegPricing leg =\r\n            match leg.Pricing with\r\n                | Some pricing -> pricing\r\n                | None -> this.legPricing strategy.Stock leg\r\n\r\n        \r\n        let payOffsPerLeg = strategy.Legs |> Seq.map (fun leg ->\r\n            let pricing = getLegPricing leg\r\n            let pricedLeg = { leg with Pricing = Some pricing }\r\n            let payoffCalculator = this.legPayoff leg.Definition pricing   \r\n            pricedLeg, payoffCalculator\r\n        )\r\n\r\n        let interestingPoints = this.getInterestingPoints strategy\r\n        let hasConverts = strategy.Legs |> Seq.exists (fun leg -> match leg.Definition with | Convertible _ -> true | _ -> false)\r\n        \r\n        match hasConverts with\r\n            | true -> \r\n                let years = [1;2;3]\r\n\r\n                let legsData = payOffsPerLeg |> Seq.map (fun (leg,payOff) -> \r\n                    leg, years |> Seq.map (fun year -> [for stockPrice in interestingPoints  do yield stockPrice, payOff year stockPrice])\r\n                )\r\n\r\n                let strategyData = years |> Seq.map (fun year -> \r\n                    [for stockPrice in interestingPoints do yield stockPrice, payOffsPerLeg |> Seq.sumBy (fun (leg,payOff) -> payOff year stockPrice)]\r\n                )\r\n\r\n                MultiYear strategyData\r\n            | false -> \r\n                let legsData = payOffsPerLeg |> Seq.map (fun (leg,payOff) -> \r\n                    leg, [for stockPrice in interestingPoints  do yield stockPrice, payOff 1 stockPrice]\r\n                )\r\n\r\n                let strategyData = [for stockPrice in interestingPoints do yield stockPrice, payOffsPerLeg |> Seq.sumBy (fun (leg,payOff) -> payOff 1 stockPrice)]\r\n                \r\n                SingleYear (strategyData,legsData)"]}