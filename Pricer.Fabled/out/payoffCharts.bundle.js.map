{"version":3,"sources":["webpack:///webpack/bootstrap ff16b3b609fc58f2fe94?67f5","webpack:///./PayoffCharts.fs","webpack:///./SimplePricer.fs?0baa","webpack:///../Pricer.Core/BlackScholesPricer.fs?a16c","webpack:///../Pricer.Core/OptionsModel.fs?3653","webpack:///./~/fable-core/fable-core.js?e03d","webpack:///./SimpleMath.fs?aec7","webpack:///./ShareViewModels.fs?c8c3","webpack:///../Pricer.Core/StocksModel.fs?f418","webpack:///../Pricer.Core/StrategiesExamples.fs?79a4","webpack:///./Charting.fs?9d86","webpack:///external \"d3\"?c0c4","webpack:///./VueHelpers.fs?962b","webpack:///../Pricer.Core/PayoffsGenerator.fs","webpack:///./Tools.fs"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA,+BAWiB,gCAXjB;AAAA,mDAY2B,8CAZ3B;;;AAAA,8BAeS;AAAA;;AACD;AAEA;AACA;AACA;AACA;;AAGU,6CAEM;AAAU;AAAA;AAAV,+BAAU,oBAAV;AAA+B;AAC/B,2BAAwB,iDAAxB;AACA;AACA,yBAAQ,qDAAR;AAA2B,UALjC;AAAA,+CAOM;AAAA;AACA;AAA2B;AARrB;AATT;;;;6BAqBT;AAAA;;AAAA,oBAAG,oBAAH,GACI,sBACiB,mCAAK,0BACW,0DADX,EAEN,8BAFM,CAAL,EADjB,CADJ,GASI,sBACiB,qCAAO;AACS;;AAChB;AACA;;AACM;;AAJC,+EAKN,oBAAH,GAAqB,uCAArB,GAA8B,wCALrB,EAMR,6CANQ;AAOnB,cAPmB,EAAP,EADjB,CATJ;AAmBK;;;;;;;;;AAvDjB,0CAyDS;AAAA;;AACD,qBAA2E,WAAvC,oBAAmB;AAAA;AAAA,UAAnB,gBAAuC,CAA3E;AACA;AACA,sBAAoB,mDAApB;AAHkB;;iEAMT;AAAc,4CACF,qCAAO,oCAGP,qBAHO,EAIT,wCAJS,EAKR,6CALQ,EAMD,qBANC,CAAP,EADE;AAYnB,qBAAiB,CAAe,wBAAf,mBAAjB;AAZW,M;;qEAeX;AAAA,qBAAiB,iBAAuB;AAAA;AAAA,UAAvB,CAAjB;AAAgE,M;;4EAG5D;AAAA;;AAAc;AACP;;AACuC,8CAA/B,mBAAkB;AAAA;AAAA,cAAlB,cAA+B;;AAFhC;AAIjB,UAJiB;;AAKP;;AACc,4CAAzB;AANe,M;;;;;;;;AAjF3B,8CA2FS;AAAA;;AACD,2BAAqF,WAAhD,oBAAmB;AAAA;AAAA,UAAnB,WAAgD,CAArF;AACA;AAFsB;;qEAMlB;AAAA;AACA;AAAuC,M;;;;;;;;;;;;;;;;;;;AAlGnD,qCAyGQ;AAAA;AAAA,EAzGR;AAAA,uBA6Ga,gEA7Gb;AA8GI;AACA;;AA/GJ,yBAgHc,kDAhHd;;;;;;;;;;;;;;;;;;;;;;;ACAA,6BAKK;AAAA;;AAED,yBAAe,2CAAuB,oCAAvB,CAAf;AAFa;;8EAK8B;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC,M;;iEAE5C;AAAA;AAG5B,M;;gFAEuC;AAAA;AAA+B,M;;;;;;;;;;;;;;;;;;;;;;;;ACjB/E,uCAIK;AAAA;;AAAmB;AAAD;;sFAGX;AAAA;;AAEA,4BAAG,uBAAH,GAEQ;AACA,uBAAE,SAAI,kCAAJ,IACE,CAAC,aAAa,MAAM,6BAApB,uBADJ,KAEE,mBAAmB,8BAFrB;AAGK,2BAAK,mBAAmB,8BAAxB;;AACA;;AACA;;AAEc,oDAAgB,SAAK,iCAAL,CAAhB;AACZ,kDAA0B,qBAA1B;;AACL;AAAA,yBAEO,4CAFP,EAEqD,MAFrD;AAAA;AAAA;AAAA;AAVA,UAAF,EAFR,GAiBU,8BAEY,kCAAL,OAAK,kCAAL,IAFP,QACa,kCAAL,OAAK,kCAAL,IADR,IAjBV;AAoBJ;AAtBe,M;;;;;;;;;;;;;;;;;;;;;;;ACHhB;AAJP,0DAKsC;AAAA,gBAAG,aAAH;AAAyC,MAL/E;;AAAA,0DAMsC;AAAA,gBAAG,oBAAH;AAAwC,MAN9E;;AAIO;AAJP,EAIO;;;AAJP;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;yDAWkC;AAAA;AAAC,M;;;;;;;;AAXnC;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;0DAgBkC;AAAA;AAAC,M;;;;;;;;AAhBnC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;6BA6B8C;AAAA;AAA4B;;;6BAC3C;AAAA;;AAAA,oBAAO;AAAC;;AAAD;AAAsC,cAAtC,EAAP;AAAoD;;;6BAC5D;AAAA,oBAAQ,wCAAR;AAAA;AAAA,gCAAqC,mCAArC;AAAsE;;;;;;;;;AA/B7F;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;6BAsC8C;AAAA;AAA4B;;;;;;;;;AAtC1E;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;6BAqD6B;AAAA,iGAGgC,wCAAR;AAAA;AAAA,yCAHxB;AAAI;;;;;;;;;AArDjC;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AAsFO;AAtFP,8CAwFc;AAAA,6CAEW,IAAS,0BAAT,OAAS,0BAFpB,GACY,IAAS,0BAAT,OAAS,0BADrB;AAAW,MAxFzB;;AAAA,wCA6FQ;AAEW;AAFX,+DAKY,+BALZ;AAOC,MApGT;;AAsFO;AAtFP,EAsFO;;;;;;;iGCtFP;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAAyD,+BAA+B;AACxF;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,uBAAuB;AAC1D;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6GAA4G,eAAe;AAC3H;AACA;;AAEA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oGAAmG,aAAa;AAChH;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA,6CAA4C,iCAAiC,6EAA6E;AAC1J;AACA,cAAa,cAAc,sDAAsD,uEAAuE;AACxJ;;AAEA;AACA,sDAAqD,8BAA8B,0EAA0E;AAC7J;AACA,cAAa,WAAW,2EAA2E;AACnG;;AAEA;AACA;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA,oCAAmC;AACnC,cAAa,IAAI;AACjB;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,mBAAmB;AACnD;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,8CAA6C;AAC7C,0BAAyB,GAAG,wEAAwE;AACpG,sBAAqB;AACrB;AACA,mDAAkD,6BAA6B;AAC/E,0BAAyB;AACzB;AACA;AACA,uCAAsC;AACtC,4CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA;AACA;AACA,0BAAyB;AACzB,sBAAqB;AACrB;AACA;AACA;AACA,0BAAyB;AACzB,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,eAAe,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,oBAAoB,EAAE,IAAI,EAAE,qCAAqC;AACjI,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,+CAA+C;;AAEpD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA2B,WAAW;AACtC;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC,8BAA6B;AAC7B;AACA,yCAAwC;AACxC;AACA,kCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mGAAkG,eAAe;AACjH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA2D,aAAa,EAAE,QAAQ,EAAE,UAAU,GAAG,KAAK,EAAE,KAAK;AAC7G,kCAAiC;AACjC;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA4B,WAAW;AACvC;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oGAAmG,eAAe;AAClH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA,+BAA8B,4BAA4B;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAAyC,EAAE;AAC3C;;AAEA;AACA,6CAA4C,EAAE;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,aAAa;AAChD;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA2B,eAAe;AAC1C,+CAA8C;AAC9C,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,4BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA6B,iBAAiB;AAC9C;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kGAAiG,mCAAmC,aAAa;AACjJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,4BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qEAAoE;AACpE;;AAEA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA,gEAA+D,iCAAiC;AAChG;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA,4DAA2D,6BAA6B;AACxF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAAyC,QAAQ;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA2B,QAAQ;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA,cAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;;AAEA;AACA,sCAAqC;AACrC;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA,+DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA,2DAA0D;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,2DAA0D;AAC1D;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAwC,QAAQ;AAChD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC,QAAQ;AAC/C;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA,sCAAqC;AACrC;AACA,gCAA+B,QAAQ;AACvC;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,cAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA,2DAA0D;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2DAA0D;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2DAA0D;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2DAA0D;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA,iCAAgC;AAChC;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,0BAAyB;AACzB;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb,8CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA,kCAAiC;AACjC;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA,0CAAyC;AACzC;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,kCAAiC;AACjC;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yEAAwE;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qEAAoE,gEAAgE;AACpI;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uEAAsE,mEAAmE;AACzI;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uEAAsE,mEAAmE;AACzI;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,0BAAyB;AACzB;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA,qBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yEAAwE;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,4EAA2E;AAC3E;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB,EAAE;AACnB;AACA,kBAAiB;AACjB;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,EAAE;AACf;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,sHAAqH;AACrH;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,mCAAkC;AAClC,sBAAqB;AACrB,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,cAAa;AACb;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,EAAE;AACf;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,mCAAkC;AAClC,sBAAqB;AACrB,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;AACL,EAAC;;;;;;;;;;;;;;;;;AC/+IM;AALP,oCAOQ;AAAA,gBAAG,KAAH;AAA6B,MAPrC;;AAAA,8BAUY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOO;AAGH,sBAAO,IAAM,QAAb;AACA,qBAAM,CAAC,CAAC,CAAE,CAAC,WAAD,KAAD,KAAD,UAAD,UAAD,QAA2C,SAAI,YAAJ,CAAjD;AAEK,sBAAC,SAAD;AAbT;AAAE,MAVd;;AAKO;AALP,EAKO;;;AALP;AAAA;AAAA;;wDA6B6B;AAAA;AAAgB,M;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7B7C,gCAIK;AAAA;;AACD;AACA;AACA;AAHe;;;;6BAKQ;AAAA;AAItB;;;;;;;;;;;;;;;;;;;;;;;ACbL;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;aCOQ,WAAM,wBAAN,C,EAA8B,WAAM,wBAAN,C;;;AAG9B;AAAA,kCACiB,qCAAO,6DAKR,6CALQ,EAMD,qBANC,CAAP,EADjB;AAUC;;AApBT,+BAsBiB;AAAA;;AAAA;AAA0B,EAA1B,EAtBjB;;AAwBY;AAAmB;AAAnB;;AAGO,yCACC,2CAAkC,wCAAlC,CADD,EAEC,2CAAkC,uCAAlC,CAFD;;AAFX;AADoB;;AAWhB;AAAW;AAAX;;AAGO,yCACC,2CAAiC,wCAAjC,CADD,EAEC,2CAAiC,uCAAjC,CAFD;;AAFX;AADY;;AAWZ;AAAA;;AAEW,yCACC,kBAAoB,yBAApB,UAAoD,wCAApD,CADD,EAEC,mBAAqB,wBAArB,UAAoD,wCAApD,CAFD,EAGC,mBAAqB,wBAArB,UAAoD,wCAApD,CAHD,EAIC,kBAAoB,yBAApB,UAAoD,wCAApD,CAJD;;AAFX;AASC;;AAGD;AAAA;;AAEW,yCAEC,kBAAoB,wBAApB,UAAmD,wCAAnD,CAFD,EAIC,mBAAqB,wBAArB,UAAoD,uCAApD,CAJD;;AAFX;AASC;;AAEc;AAAA;;AAEJ,yCAEC,mBAAqB,wBAArB,UAAoD,wCAApD,CAFD,EAIC,kBAAoB,wBAApB,UAAmD,uCAAnD,CAJD,EAMC,sBACiB,mCAAK,gDAAL,EADjB,CAND;;AAFI;AAiBd;;AAGD;AAAA;;AAEW,yCAEC,mBAAqB,wBAArB,UAAoD,wCAApD,CAFD,EAIC,sBACiB,mCAAK,gDAAL,EADjB,CAJD;;AAFX;AAeC;;AAEuB;AAAA;AAAY;;AAGhC;AAAU,8BAAM,wBAAN;AACA,8BAAM,wBAAN;AACA;AACA;AAHV;;AAMO,yCACC,oCAAmC,wCAAnC,CADD,EAEC,mCAAkC,wCAAlC,CAFD,EAGC,oCAAmC,wCAAnC,CAHD,EAIC,mCAAkC,wCAAlC,CAJD;;AAFX;AAJW;;AAgBP;AAAmB;AAAnB;;AAGO,yCACC,2CAAkC,wCAAlC,CADD,EAEC,4CAAmC,wCAAnC,CAFD,EAGC,2CAAkC,wCAAlC,CAHD,EAIC,4CAAmC,wCAAnC,CAJD;;AAFX;AADoB;;AAYH;AAAA;;AAEV,yCACC,kBAAoB,wBAApB,UAAmD,wCAAnD,CADD;;AAFU;AAMpB;;AAEqB;AAAA;;AAEX,yCACC,mBAAqB,wBAArB,UAAoD,wCAApD,CADD;;AAFW;AAMrB;;AAGO;AAAkB;AAAlB;;AAGO,yCACC,4CAAmC,wCAAnC,CADD,EAEC,2CAAkC,wCAAlC,CAFD;;AAFX;AADmB;;AAWf;AAAkB;AAAlB;;AAGO,yCACC,4CAAmC,uCAAnC,CADD,EAEC,2CAAkC,uCAAlC,CAFD;;AAFX;AADmB;;AAUQ;AAAA,qCAC3B,eAD2B,EAE3B,gBAF2B,EAG3B,iBAH2B,EAI3B,gBAJ2B,EAK3B,eAL2B,EAM3B,eAN2B,EAO3B,gBAP2B,EAQ3B,mBAR2B,EAS3B,aAT2B,EAU3B,aAV2B,EAW3B,gBAX2B,EAY3B,kBAZ2B;AAa9B;;AA5LL,2CA8LuB;AAAA;AAAA;AAAA;AAIlB,EAJkB,EA9LvB;;AAAA,qDAoM4B,gCApM5B;;AAuMoC;AAAA,gCAAgB;AAAA;AAAA,MAAhB,EAA5B,yBAA4B;AAA6B;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvMjE;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AA4BO;AAAA;AAAS,EAAT;;6BA5BP;AAAA;AAAA,E;;;;;;;AAAA,0BA0CK;AAAA;;AAAA,sDAAc,iBAAd;;AAAA;AAAS;;2FACuD;AAAA;AAAiB,M;;;;;;;;;;AA3CtF,6BA8CK;AAAA;;AAAA,uDAAiB,kBAAjB;;AAAA;AAAY;;oEACkD;AAAA;AAAiB,M;;;;;;;AAW7E;AA1DP,oDAkEiB;AAAA,2BALG,oBACJ;AAAA;AAAA,UADI,OAKH;AAAY,MAlE7B;;AAAA,4CAqEgB;AAAA,mCACJ;AAAA,6DAEyB,4BAFzB;AAAA,UADI;AAIF,MAzEd;;AAAA,wDA4EY;AAAQ;AACZ,8DAAqD,iBAArD;AACA,oDAA2C,iBAA3C;AAFI;AAAK,MAAL,EA5EZ;;AAAA,0EAmFY;AAAU;AACd;AADI;AAAO,MAnFnB;;AAAA,0CAwFY;AAAe;AACnB;AACA;AAFgB,MAxFxB;;AAAA,kDA8FY;AAAA;AACJ;AADS,MA9FjB;;AAAA,4CAkGY;AACM,mDAEM;AAAW;AACI,uDAEU,8BAFV;AAQd,+BAFD;AAAA,wDACA;AAAA;AAAA,mBADA;AAAA,eAEC;AATO,UAAR,EAFN,GAYK;AAAA;AAA0B,UAA1B,EAZL;AAcV;AAAA;AAAoB,UAApB;AAfU,MAlGlB;;AAAA,wEAoHQ;AAAA;AAIC,MAxHT;;AAAA,8CA2HY;AAAS;;AACD,6HAA2F,cAA3F;;AACK;;AACjB;AACA,gCACQ;AAAY;AAChB;AADa,UADjB;AAIA;AARU,MA3HlB;;AA0DO;AA1DP,EA0DO;;;;;;;AC1DP,qB;;;;;;;;;;ACaO;AAbP,kDAeY;AAAU;AACC;AACH;AACH;AAAA;;AAAA,iKACD;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAO;AACL;;AAAA,yCAIF;AAAA,mCAAgB;AAAA;AAAA;AAAA,sBAAhB;AAGC,kBAPC,MAEF;AAAA;AAAgB;AAHZ;AADgC;AAU5C;AACA;AACA;AACA;AAhBW,MAfnB;;AAaO;AAbP,EAaO;;;;;;;;;;;;;;;;;;;;;ACbP,uCAIK;AAAA;;AAAkB;AAAF;;6EAGP;AAAA;;AAAA,mDAEoB;AAAA;AAAA;AAAA;AAAA,2CAFpB,2CAG2B;AAAA;AAAA;AAAA;AAAA,2CAH3B,GACgB,+CADhB;AAAc,M;;+FAOpB;AAAA,gBAAoB,qCAApB,GAAqC,sBAArC,GAEQ;AAA2B,+CACrB;AAAA;AAAA,cADqB;;AAMrB,6BAAgB;AAAA;AAAA,wBAAhB;;AACA,6BAAgB;AAAA;AAAA,wBAAhB;;AAEN;AAAA,6EACA;AAAA,kDAAmB;AAAA;AAAA,gCAAnB,EACA;AAAA;AAAA,uBADA;AAAA,mBADA;AAAA;AATO,UAAP,EAFR;AAcK,M;;+FAEC;AAAA,wCAGoB,2BAAuB,mFAAvB,CAHpB,gCAI2B,2BAAyB,uEAAzB,CAJ3B,GAEgB,2BAAqB,gCAArB,CAFhB;AAAG,M;;qFAQL;AAAA;;AACM;AAAA,0CAEQ;AAAA;AAAA;AAAA;AAAA,mCAFR;AAAA;;AAK2B,gDAC7B;AAAU;;AACE;AAAA;AAAA;AAAmC,cAAnC;;AACO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFnB;AAAO,UADsB;;AAOb;;AACW,iDAA6B;AAAA;AAAA,UAA7B;;AAE7B,0BAEM;AAAA;AAAQ;;AAEoB;AAAA,2CACd,mBAAqB;AAAA,sDAAC;AAAA;AAAA,qDAA0D,8BAA1D;AAAA;AAAA,2BAAD;AAAA,sBAArB,QADc;AAAA;;AAIJ,uDACxB;AAAA,kDAAC;AAAA;AAAA,iDAA0E,qBAA+B;AAAA;AAAA,8BAA/B,gBAA1E;AAAA;AAAA,uBAAD;AAAA,kBADwB;;AAI5B;AAAA;AAAA;AAVI;;AAAA;AAAK,UAFX,MAcM;AAA4B;AAAA,uCACvB,sBAAC;AAAA;AAAA,6CAA0D,2BAA1D;AAAA;AAAA,mBAAD,CADuB;AAAA;;AAIb,uDAAC;AAAA;AAAA,yCAA0E,qBAA+B;AAAA;AAAA,sBAA/B,gBAA1E;AAAA;AAAA,eAAD;;AAEnB;AANY;AA9BC,M;;;;;;;;;;;;;;;;;;;;AC/BjB;AAAS;;AACF;AACC;AACF;AACV;AAJU;;AAQV;AAAA,YAAQ,0CAAR;AAAA;AAAA,QAAuB,0BAAvB,EAAiC,2BAAjC,EAA4C,yBAA5C;AAAoD","file":"payoffCharts.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ff16b3b609fc58f2fe94\n **/","﻿namespace Pricer.Fabled\n\nopen System\nopen Pricer.Core\nopen Fable.Core\nopen Fable.Import\nopen Fable.Core.JsInterop\nopen System.Text.RegularExpressions\n\nmodule PayoffCharts =\n    \n    let pricer = new SimplePricer()\n    let payoffsGenerator = new PayoffsGenerator(pricer)\n    \n\n    type LegViewModel(l:Leg) = \n        let mutable leg =l \n        // All these things are strings, because they come from text fields later and vuejs will give us string :(\n        let mutable strike = \"0.0\"\n        let mutable expiry = \"test\"\n        let mutable kind = \"Option\"\n        let mutable direction = \"Buy\"       \n\n        do \n            match l.Definition with\n                    | Option opt -> \n                        strike <- opt.Strike.ToString()\n                        expiry <- opt.Expiry |> Tools.toDate\n                        direction <- opt.BuyVsSell\n                        kind <- opt.Kind.ToString()\n                    | Cash cash -> \n                        kind <- \"Cash\"\n                        direction <- cash.BuyVsSell\n                    | _ -> ()\n        \n        member __.getLeg = \n            if kind = \"Cash\" then \n                {\n                    Definition = Cash { \n                        Direction = direction |> Transforms.stringToDirection\n                        Price = float strike\n                    }\n                    Pricing = None\n                }\n            else\n                {\n                    Definition = Option { \n                        Direction = direction |> Transforms.stringToDirection\n                        Expiry = Tools.parseDate expiry\n                        Strike = float strike\n                        PurchaseDate = DateTime.Now\n                        Kind = if kind = \"Put\" then Put else Call\n                        Style = European\n                    }\n                    Pricing = None\n                }\n\n    type StrategyViewModel(strategy) =\n        let mutable legs = strategy.Legs |> List.map (fun l -> LegViewModel(l)) |> Array.ofList\n        let mutable name = strategy.Name\n        let mutable stock = new StockViewModel(strategy.Stock)\n        \n        member __.addLeg(event) = \n            let  newLeg: Leg = {\n                Definition = Option {\n                    Direction = 1.0\n                    Strike = 100.0\n                    Expiry = DateTime.Now\n                    Kind = Call\n                    Style = European\n                    PurchaseDate = DateTime.Now\n                }\n                Pricing = None\n            }\n\n            legs <- (legs |> Array.append [|new LegViewModel(newLeg)|])\n        \n        member __.removeLeg(leg:LegViewModel) =\n            legs <- (legs |> Array.filter (fun l -> l.getLeg <> leg.getLeg))\n\n        member __.generatePayoff() = \n            let newStrategy = {\n                Name = name\n                Legs = legs |> Seq.map (fun l -> l.getLeg) |> List.ofSeq\n                Stock = stock.buildStock\n            }\n            let data = payoffsGenerator.getStrategyData newStrategy\n            Charting.drawPayoff data \"#payoffChart\"\n\n\n\n    type StrategyListViewModel(examples) = \n        let mutable strategies = examples |> List.map (fun s -> new StrategyViewModel(s)) |> Array.ofList\n        let mutable selectedStrategy: StrategyViewModel option = None\n\n        member __.allStrategies = strategies\n        member __.select strat = \n            selectedStrategy <- Some strat\n            selectedStrategy.Value.generatePayoff()\n\n        member __.strategy = selectedStrategy\n       \n    \n\n    let extraOpts =\n        createObj [\n            \"el\" ==> \".payoffapp\"           \n        ]\n\n    let vm = StrategyListViewModel(StrategiesExamples.exampleStrategies)\n    vm.select vm.allStrategies.[4]\n    vm.strategy.Value.generatePayoff()\n    let app = VueHelper.createFromObj(vm, extraOpts)\n\n\n/** WEBPACK FOOTER **\n ** ./PayoffCharts.fs\n **/","﻿namespace Pricer.Fabled\r\n\r\nopen System\r\nopen Pricer.Core\r\n\r\ntype SimplePricer()= \r\n    \r\n    let bsPricer = new BlackScholesPricer(new SimpleMathProvider())\r\n\r\n    interface IPricer with\r\n        member this.priceOption stock option = bsPricer.blackScholes stock option\r\n\r\n        member this.priceCash cash = {\r\n            Premium = cash.Price\r\n            Delta = 1.0\r\n        }\r\n\r\n        member this.priceConvert stock option = failwith \"implement CB pricing\"\n\n\n/** WEBPACK FOOTER **\n ** ./SimplePricer.fs\n **/","﻿namespace Pricer.Core\r\n\r\nopen System\r\n\r\ntype BlackScholesPricer(math:IMathProvider) = \r\n    \r\n    member this.blackScholes (stock:StockInfo) (option:OptionLeg) =\r\n        let price,delta =\r\n            // We can only calculate if the option concerns the future\r\n            if option.TimeToExpiry > 0.0 then\r\n                // Calculate d1 and d2 and pass them to cumulative distribution\r\n                let d1 =\r\n                    ( log(stock.CurrentPrice / option.Strike) +\r\n                        (stock.Rate + 0.5 * pown stock.Volatility 2) * option.TimeToExpiry ) /\r\n                    ( stock.Volatility * sqrt option.TimeToExpiry )\r\n                let d2 = d1 - stock.Volatility * sqrt option.TimeToExpiry\r\n                let N1 = math.cdf(d1)\r\n                let N2 = math.cdf(d2)\r\n\r\n                let discountedStrike = option.Strike * exp (-stock.Rate * option.TimeToExpiry)\r\n                let call = stock.CurrentPrice * N1 - discountedStrike * N2\r\n                match option.Kind with\r\n                    | Call -> call, N1\r\n                    | Put -> call + discountedStrike - stock.CurrentPrice, N1 - 1.0\r\n            else\r\n                // If the option has expired, calculate payoff directly\r\n                match option.Kind with\r\n                    | Call -> max (stock.CurrentPrice - option.Strike) 0.0,1.0\r\n                    | Put -> max (option.Strike - stock.CurrentPrice) 0.0,1.0\r\n        {\r\n            Premium = price\r\n            Delta = delta\r\n        }\r\n\r\n    \r\n\n\n\n/** WEBPACK FOOTER **\n ** ../Pricer.Core/BlackScholesPricer.fs\n **/","﻿namespace Pricer.Core\n\nopen System\n\nmodule Transforms = \n    let directionToString direction = if direction < 0.0 then \"Sell\" else \"Buy\"\n    let stringToDirection direction = if direction = \"Sell\" then -1.0 else 1.0\n\ntype OptionKind =\n    | Call\n    | Put\n    override x.ToString() = match x with | Call -> \"Call\" | _ -> \"Put\"\n\ntype OptionStyle =\n    | American\n    | European\n    override x.ToString() = match x with | American -> \"American\" | _ -> \"European\"\n\n\n\ntype OptionLeg =\n    {\n        Direction : float\n        Strike : float\n        Expiry : DateTime\n        Kind : OptionKind\n        Style: OptionStyle\n        PurchaseDate: DateTime\n    }\n    member this.BuyVsSell = this.Direction |> Transforms.directionToString\n    member this.TimeToExpiry = (float (this.Expiry - this.PurchaseDate).Days)/365.0\n    member this.Name = sprintf \"%s %s %.2f\" this.BuyVsSell (this.Kind.ToString()) this.Strike\n\ntype CashLeg = \n    {\n        Direction: float\n        Price:float\n    }\n    member this.BuyVsSell = this.Direction |> Transforms.directionToString\n\ntype ConvertibleLeg = {\n    Direction: float\n    Coupon: float\n    ConversionRatio: float\n    Maturity: DateTime\n    FaceValue: float\n    ReferencePrice: float\n}\n\ntype LegInfo =\n    | Cash of CashLeg\n    | Option of OptionLeg\n    | Convertible of ConvertibleLeg\n    member this.Name = match this with\n                            | Cash cl -> \"Cash\"\n                            | Option ol -> ol.Name\n                            | Convertible convert -> sprintf \"Convert %f\" convert.FaceValue\ntype Pricing = {\n    Delta: float\n    Premium: float\n}\n\ntype Leg = {\n    Definition:LegInfo\n    Pricing:Pricing option\n}\n\ntype Strategy = {\n    Stock : StockInfo\n    Name : String\n    Legs: Leg list\n}\n\ntype LegData = {\n    Leg:Leg\n    LegData: float*float list\n}\n\ntype SingleLine =  (float*float) list\n\ntype LegsData = Leg * SingleLine\n\ntype StrategyData = \n    | SingleYear of SingleLine * ((Leg * SingleLine) seq)\n    | MultiYear of SingleLine seq\n\nmodule BasicOptions = \n    let optionValue option stockPrice =\n        match option.Kind with\n                | Call -> max 0.0 (stockPrice - option.Strike)\n                | Put -> max 0.0 (option.Strike - stockPrice)\n\n    let buildLeg kind strike direction style expiry buyingDate =\n        {\n            Strike=strike\n            Kind = Call\n            Direction = direction\n            Expiry = expiry\n            Style = European\n            PurchaseDate = buyingDate\n        }\n\n\ntype IMathProvider = \n    abstract member cdf: float -> float\n\ntype IPricer =\n    abstract member priceOption: StockInfo -> OptionLeg -> Pricing\n    abstract member priceCash: CashLeg -> Pricing\n    abstract member priceConvert: StockInfo -> ConvertibleLeg -> Pricing\n\n\n/** WEBPACK FOOTER **\n ** ../Pricer.Core/OptionsModel.fs\n **/","(function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"exports\"], factory);\n    } else if (typeof exports !== \"undefined\") {\n        factory(exports);\n    } else {\n        var mod = {\n            exports: {}\n        };\n        factory(mod.exports);\n        global.fableCore = mod.exports;\n    }\n})(this, function (exports) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.Tuple = Tuple;\n    exports.Tuple3 = Tuple3;\n\n    var _slicedToArray = function () {\n        function sliceIterator(arr, i) {\n            var _arr = [];\n            var _n = true;\n            var _d = false;\n            var _e = undefined;\n\n            try {\n                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n                    _arr.push(_s.value);\n\n                    if (i && _arr.length === i) break;\n                }\n            } catch (err) {\n                _d = true;\n                _e = err;\n            } finally {\n                try {\n                    if (!_n && _i[\"return\"]) _i[\"return\"]();\n                } finally {\n                    if (_d) throw _e;\n                }\n            }\n\n            return _arr;\n        }\n\n        return function (arr, i) {\n            if (Array.isArray(arr)) {\n                return arr;\n            } else if (Symbol.iterator in Object(arr)) {\n                return sliceIterator(arr, i);\n            } else {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n            }\n        };\n    }();\n\n    function _defineProperty(obj, key, value) {\n        if (key in obj) {\n            Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true\n            });\n        } else {\n            obj[key] = value;\n        }\n\n        return obj;\n    }\n\n    function _possibleConstructorReturn(self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n    } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n    };\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var fableGlobal = function () {\n        var globalObj = typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : null;\n        if (typeof globalObj.__FABLE_CORE__ == \"undefined\") {\n            globalObj.__FABLE_CORE__ = {\n                types: new Map(),\n                symbols: {\n                    interfaces: Symbol(\"interfaces\"),\n                    typeName: Symbol(\"typeName\")\n                }\n            };\n        }\n        return globalObj.__FABLE_CORE__;\n    }();\n    var FSymbol = fableGlobal.symbols;\n    exports.Symbol = FSymbol;\n    function Tuple(x, y) {\n        return [x, y];\n    }\n    function Tuple3(x, y, z) {\n        return [x, y, z];\n    }\n\n    var Util = exports.Util = function () {\n        function Util() {\n            _classCallCheck(this, Util);\n        }\n\n        // For legacy reasons the name is kept, but this method also adds\n        // the type name to a cache. Use it after declaration:\n        // Util.setInterfaces(Foo.prototype, [\"IFoo\", \"IBar\"], \"MyModule.Foo\");\n        Util.setInterfaces = function setInterfaces(proto, interfaces, typeName) {\n            if (Array.isArray(interfaces) && interfaces.length > 0) {\n                var currentInterfaces = proto[FSymbol.interfaces];\n                if (Array.isArray(currentInterfaces)) {\n                    for (var i = 0; i < interfaces.length; i++) {\n                        if (currentInterfaces.indexOf(interfaces[i]) == -1) currentInterfaces.push(interfaces[i]);\n                    }\n                } else proto[FSymbol.interfaces] = interfaces;\n            }\n            if (typeName) {\n                proto[FSymbol.typeName] = typeName;\n                fableGlobal.types.set(typeName, proto.constructor);\n            }\n        };\n\n        Util.hasInterface = function hasInterface(obj) {\n            for (var _len2 = arguments.length, interfaceNames = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                interfaceNames[_key2 - 1] = arguments[_key2];\n            }\n\n            return Array.isArray(obj[FSymbol.interfaces]) && obj[FSymbol.interfaces].some(function (x) {\n                return interfaceNames.indexOf(x) >= 0;\n            });\n        };\n\n        Util.getTypeFullName = function getTypeFullName(cons) {\n            if (cons.prototype && cons.prototype[FSymbol.typeName]) {\n                return cons.prototype[FSymbol.typeName];\n            } else {\n                return cons.name || \"unknown\";\n            }\n        };\n\n        Util.getTypeNamespace = function getTypeNamespace(cons) {\n            var fullName = Util.getTypeFullName(cons);\n            var i = fullName.lastIndexOf('.');\n            return i > -1 ? fullName.substr(0, i) : \"\";\n        };\n\n        Util.getTypeName = function getTypeName(cons) {\n            var fullName = Util.getTypeFullName(cons);\n            var i = fullName.lastIndexOf('.');\n            return fullName.substr(i + 1);\n        };\n\n        Util.getRestParams = function getRestParams(args, idx) {\n            for (var _len = args.length, restArgs = Array(_len > idx ? _len - idx : 0), _key = idx; _key < _len; _key++) {\n                restArgs[_key - idx] = args[_key];\n            }return restArgs;\n        };\n\n        Util.toString = function toString(o) {\n            return o != null && typeof o.ToString == \"function\" ? o.ToString() : String(o);\n        };\n\n        Util.equals = function equals(x, y) {\n            if (x == null) return y == null;else if (y == null) return false;else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y)) return false;else if (Array.isArray(x) || ArrayBuffer.isView(x)) return x.length != y.length ? false : Seq.fold2(function (prev, v1, v2) {\n                return !prev ? prev : Util.equals(v1, v2);\n            }, true, x, y);else if (x instanceof Date) return FDate.equals(x, y);else if (Util.hasInterface(x, \"System.IEquatable\")) return x.Equals(y);else return x === y;\n        };\n\n        Util.compare = function compare(x, y) {\n            if (x == null) return y == null ? 0 : -1;else if (y == null) return -1;else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y)) return -1;else if (Array.isArray(x) || ArrayBuffer.isView(x)) return x.length != y.length ? x.length < y.length ? -1 : 1 : Seq.fold2(function (prev, v1, v2) {\n                return prev !== 0 ? prev : Util.compare(v1, v2);\n            }, 0, x, y);else if (Util.hasInterface(x, \"System.IComparable\")) return x.CompareTo(y);else return x < y ? -1 : x > y ? 1 : 0;\n        };\n\n        Util.equalsRecords = function equalsRecords(x, y) {\n            var keys = Object.getOwnPropertyNames(x);\n            for (var i = 0; i < keys.length; i++) {\n                if (!Util.equals(x[keys[i]], y[keys[i]])) return false;\n            }\n            return true;\n        };\n\n        Util.compareRecords = function compareRecords(x, y) {\n            var keys = Object.getOwnPropertyNames(x);\n            for (var i = 0; i < keys.length; i++) {\n                var res = Util.compare(x[keys[i]], y[keys[i]]);\n                if (res !== 0) return res;\n            }\n            return 0;\n        };\n\n        Util.equalsUnions = function equalsUnions(x, y) {\n            if (x.Case !== y.Case) return false;\n            for (var i = 0; i < x.Fields.length; i++) {\n                if (!Util.equals(x.Fields[i], y.Fields[i])) return false;\n            }\n            return true;\n        };\n\n        Util.compareUnions = function compareUnions(x, y) {\n            var res = Util.compare(x.Case, y.Case);\n            if (res !== 0) return res;\n            for (var i = 0; i < x.Fields.length; i++) {\n                res = Util.compare(x.Fields[i], y.Fields[i]);\n                if (res !== 0) return res;\n            }\n            return 0;\n        };\n\n        Util.createDisposable = function createDisposable(f) {\n            var disp = { Dispose: f };\n            disp[FSymbol.interfaces] = [\"System.IDisposable\"];\n            return disp;\n        };\n\n        Util.createObj = function createObj(fields) {\n            return Seq.fold(function (acc, kv) {\n                acc[kv[0]] = kv[1];return acc;\n            }, {}, fields);\n        };\n\n        return Util;\n    }();\n\n    Util.toPlainJsObj = function (source) {\n        if (source != null && source.constructor != Object) {\n            var target = {};\n            var props = Object.getOwnPropertyNames(source);\n            for (var i = 0; i < props.length; i++) {\n                target[props[i]] = source[props[i]];\n            }\n            // Copy also properties from prototype, see #192\n            var proto = Object.getPrototypeOf(source);\n            if (proto != null) {\n                props = Object.getOwnPropertyNames(proto);\n                for (var _i = 0; _i < props.length; _i++) {\n                    var prop = Object.getOwnPropertyDescriptor(proto, props[_i]);\n                    if (prop.value) {\n                        target[props[_i]] = prop.value;\n                    } else if (prop.get) {\n                        target[props[_i]] = prop.get.apply(source);\n                    }\n                }\n            }\n            return target;\n        } else {\n            return source;\n        }\n    };\n\n    var Serialize = exports.Serialize = function () {\n        function Serialize() {\n            _classCallCheck(this, Serialize);\n        }\n\n        Serialize.toJson = function toJson(o) {\n            return JSON.stringify(o, function (k, v) {\n                if (ArrayBuffer.isView(v)) {\n                    return Array.from(v);\n                } else if (v != null && (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\") {\n                    if (v instanceof List || v instanceof FSet || v instanceof Set) {\n                        return {\n                            $type: v[FSymbol.typeName] || \"System.Collections.Generic.HashSet\",\n                            $values: Array.from(v) };\n                    } else if (v instanceof FMap || v instanceof Map) {\n                        return Seq.fold(function (o, kv) {\n                            o[kv[0]] = kv[1];return o;\n                        }, { $type: v[FSymbol.typeName] || \"System.Collections.Generic.Dictionary\" }, v);\n                    } else if (v[FSymbol.typeName]) {\n                        if (Util.hasInterface(v, \"FSharpUnion\", \"FSharpRecord\", \"FSharpException\")) {\n                            return Object.assign({ $type: v[FSymbol.typeName] }, v);\n                        } else {\n                            var proto = Object.getPrototypeOf(v),\n                                props = Object.getOwnPropertyNames(proto),\n                                _o = { $type: v[FSymbol.typeName] };\n                            for (var i = 0; i < props.length; i++) {\n                                var prop = Object.getOwnPropertyDescriptor(proto, props[i]);\n                                if (prop.get) _o[props[i]] = prop.get.apply(v);\n                            }\n                            return _o;\n                        }\n                    }\n                }\n                return v;\n            });\n        };\n\n        Serialize.ofJson = function ofJson(json, expected) {\n            var parsed = JSON.parse(json, function (k, v) {\n                if (v == null) return v;else if ((typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && typeof v.$type === \"string\") {\n                    // Remove generic args and assembly info added by Newtonsoft.Json\n                    var type = v.$type.replace('+', '.'),\n                        i = type.indexOf('`');\n                    if (i > -1) {\n                        type = type.substr(0, i);\n                    } else {\n                        i = type.indexOf(',');\n                        type = i > -1 ? type.substr(0, i) : type;\n                    }\n                    if (type === \"System.Collections.Generic.List\" || type.indexOf(\"[]\") === type.length - 2) {\n                        return v.$values;\n                    }\n                    if (type === \"Microsoft.FSharp.Collections.FSharpList\") {\n                        return List.ofArray(v.$values);\n                    } else if (type == \"Microsoft.FSharp.Collections.FSharpSet\") {\n                        return FSet.create(v.$values);\n                    } else if (type == \"System.Collections.Generic.HashSet\") {\n                        return new Set(v.$values);\n                    } else if (type == \"Microsoft.FSharp.Collections.FSharpMap\") {\n                        delete v.$type;\n                        return FMap.create(Object.getOwnPropertyNames(v).map(function (k) {\n                            return [k, v[k]];\n                        }));\n                    } else if (type == \"System.Collections.Generic.Dictionary\") {\n                        delete v.$type;\n                        return new Map(Object.getOwnPropertyNames(v).map(function (k) {\n                            return [k, v[k]];\n                        }));\n                    } else {\n                        var T = fableGlobal.types.get(type);\n                        if (T) {\n                            delete v.$type;\n                            return Object.assign(new T(), v);\n                        }\n                    }\n                } else if (/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:[+-]\\d{2}:\\d{2}|Z)$/.test(v)) return FDate.parse(v);else return v;\n            });\n            if (parsed != null && typeof expected == \"function\" && !(parsed instanceof expected)) {\n                throw \"JSON is not of type \" + expected.name + \": \" + json;\n            }\n            return parsed;\n        };\n\n        return Serialize;\n    }();\n\n    var GenericComparer = exports.GenericComparer = function GenericComparer(f) {\n        _classCallCheck(this, GenericComparer);\n\n        this.Compare = f || Util.compare;\n    };\n\n    Util.setInterfaces(GenericComparer.prototype, [\"System.IComparer\"], \"Fable.Core.GenericComparer\");\n\n    var Choice = exports.Choice = function () {\n        function Choice(t, d) {\n            _classCallCheck(this, Choice);\n\n            this.Case = t;\n            this.Fields = d;\n        }\n\n        Choice.Choice1Of2 = function Choice1Of2(v) {\n            return new Choice(\"Choice1Of2\", [v]);\n        };\n\n        Choice.Choice2Of2 = function Choice2Of2(v) {\n            return new Choice(\"Choice2Of2\", [v]);\n        };\n\n        Choice.prototype.Equals = function Equals(other) {\n            return Util.equalsUnions(this, other);\n        };\n\n        Choice.prototype.CompareTo = function CompareTo(other) {\n            return Util.compareUnions(this, other);\n        };\n\n        _createClass(Choice, [{\n            key: \"valueIfChoice1\",\n            get: function get() {\n                return this.Case === \"Choice1Of2\" ? this.Fields[0] : null;\n            }\n        }, {\n            key: \"valueIfChoice2\",\n            get: function get() {\n                return this.Case === \"Choice2Of2\" ? this.Fields[0] : null;\n            }\n        }]);\n\n        return Choice;\n    }();\n\n    Util.setInterfaces(Choice.prototype, [\"FSharpUnion\", \"System.IEquatable\", \"System.IComparable\"], \"Microsoft.FSharp.Core.FSharpChoice\");\n\n    var TimeSpan = exports.TimeSpan = function (_Number) {\n        _inherits(TimeSpan, _Number);\n\n        function TimeSpan() {\n            _classCallCheck(this, TimeSpan);\n\n            return _possibleConstructorReturn(this, _Number.apply(this, arguments));\n        }\n\n        TimeSpan.create = function create() {\n            var d = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n            var h = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n            var m = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n            var s = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n            var ms = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];\n\n            switch (arguments.length) {\n                case 1:\n                    // ticks\n                    return this.fromTicks(arguments[0]);\n                case 3:\n                    // h,m,s\n                    d = 0, h = arguments[0], m = arguments[1], s = arguments[2], ms = 0;\n                    break;\n                default:\n                    // d,h,m,s,ms\n                    d = arguments[0], h = arguments[1], m = arguments[2], s = arguments[3], ms = arguments[4] || 0;\n                    break;\n            }\n            return d * 86400000 + h * 3600000 + m * 60000 + s * 1000 + ms;\n        };\n\n        TimeSpan.fromTicks = function fromTicks(ticks) {\n            return ticks / 10000;\n        };\n\n        TimeSpan.fromDays = function fromDays(d) {\n            return TimeSpan.create(d, 0, 0, 0);\n        };\n\n        TimeSpan.fromHours = function fromHours(h) {\n            return TimeSpan.create(h, 0, 0);\n        };\n\n        TimeSpan.fromMinutes = function fromMinutes(m) {\n            return TimeSpan.create(0, m, 0);\n        };\n\n        TimeSpan.fromSeconds = function fromSeconds(s) {\n            return TimeSpan.create(0, 0, s);\n        };\n\n        TimeSpan.days = function days(ts) {\n            return Math.floor(ts / 86400000);\n        };\n\n        TimeSpan.hours = function hours(ts) {\n            return Math.floor(ts % 86400000 / 3600000);\n        };\n\n        TimeSpan.minutes = function minutes(ts) {\n            return Math.floor(ts % 3600000 / 60000);\n        };\n\n        TimeSpan.seconds = function seconds(ts) {\n            return Math.floor(ts % 60000 / 1000);\n        };\n\n        TimeSpan.milliseconds = function milliseconds(ts) {\n            return Math.floor(ts % 1000);\n        };\n\n        TimeSpan.ticks = function ticks(ts) {\n            return ts * 10000;\n        };\n\n        TimeSpan.totalDays = function totalDays(ts) {\n            return ts / 86400000;\n        };\n\n        TimeSpan.totalHours = function totalHours(ts) {\n            return ts / 3600000;\n        };\n\n        TimeSpan.totalMinutes = function totalMinutes(ts) {\n            return ts / 60000;\n        };\n\n        TimeSpan.totalSeconds = function totalSeconds(ts) {\n            return ts / 1000;\n        };\n\n        TimeSpan.negate = function negate(ts) {\n            return ts * -1;\n        };\n\n        TimeSpan.add = function add(ts1, ts2) {\n            return ts1 + ts2;\n        };\n\n        TimeSpan.subtract = function subtract(ts1, ts2) {\n            return ts1 - ts2;\n        };\n\n        return TimeSpan;\n    }(Number);\n\n    TimeSpan.compare = Util.compare;\n    TimeSpan.compareTo = Util.compare;\n    TimeSpan.duration = Math.abs;\n    var DateKind = exports.DateKind = undefined;\n    (function (DateKind) {\n        DateKind[DateKind[\"UTC\"] = 1] = \"UTC\";\n        DateKind[DateKind[\"Local\"] = 2] = \"Local\";\n    })(DateKind || (exports.DateKind = DateKind = {}));\n\n    var FDate = function (_Date) {\n        _inherits(FDate, _Date);\n\n        function FDate() {\n            _classCallCheck(this, FDate);\n\n            return _possibleConstructorReturn(this, _Date.apply(this, arguments));\n        }\n\n        FDate.__changeKind = function __changeKind(d, kind) {\n            var d2 = void 0;\n            return d.kind == kind ? d : (d2 = new Date(d.getTime()), d2.kind = kind, d2);\n        };\n\n        FDate.__getValue = function __getValue(d, key) {\n            return d[(d.kind == DateKind.UTC ? \"getUTC\" : \"get\") + key]();\n        };\n\n        FDate.minValue = function minValue() {\n            return FDate.parse(-8640000000000000, 1);\n        };\n\n        FDate.maxValue = function maxValue() {\n            return FDate.parse(8640000000000000, 1);\n        };\n\n        FDate.parse = function parse(v, kind) {\n            var date = v == null ? new Date() : new Date(v);\n            if (isNaN(date.getTime())) throw \"The string is not a valid Date.\";\n            date.kind = kind || (typeof v == \"string\" && v.slice(-1) == \"Z\" ? DateKind.UTC : DateKind.Local);\n            return date;\n        };\n\n        FDate.create = function create(year, month, day) {\n            var h = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n            var m = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];\n            var s = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];\n            var ms = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];\n            var kind = arguments.length <= 7 || arguments[7] === undefined ? DateKind.Local : arguments[7];\n\n            var date = kind === DateKind.UTC ? new Date(Date.UTC(year, month - 1, day, h, m, s, ms)) : new Date(year, month - 1, day, h, m, s, ms);\n            if (isNaN(date.getTime())) throw \"The parameters describe an unrepresentable Date.\";\n            date.kind = kind;\n            return date;\n        };\n\n        FDate.utcNow = function utcNow() {\n            return FDate.parse(null, 1);\n        };\n\n        FDate.today = function today() {\n            return FDate.date(FDate.now());\n        };\n\n        FDate.isLeapYear = function isLeapYear(year) {\n            return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n        };\n\n        FDate.daysInMonth = function daysInMonth(year, month) {\n            return month == 2 ? FDate.isLeapYear(year) ? 29 : 28 : month >= 8 ? month % 2 == 0 ? 31 : 30 : month % 2 == 0 ? 30 : 31;\n        };\n\n        FDate.toUniversalTime = function toUniversalTime(d) {\n            return FDate.__changeKind(d, 1);\n        };\n\n        FDate.toLocalTime = function toLocalTime(d) {\n            return FDate.__changeKind(d, 2);\n        };\n\n        FDate.timeOfDay = function timeOfDay(d) {\n            return TimeSpan.create(0, FDate.hour(d), FDate.minute(d), FDate.second(d), FDate.millisecond(d));\n        };\n\n        FDate.date = function date(d) {\n            return FDate.create(FDate.year(d), FDate.month(d), FDate.day(d), 0, 0, 0, 0, d.kind);\n        };\n\n        FDate.day = function day(d) {\n            return FDate.__getValue(d, \"Date\");\n        };\n\n        FDate.hour = function hour(d) {\n            return FDate.__getValue(d, \"Hours\");\n        };\n\n        FDate.millisecond = function millisecond(d) {\n            return FDate.__getValue(d, \"Milliseconds\");\n        };\n\n        FDate.minute = function minute(d) {\n            return FDate.__getValue(d, \"Minutes\");\n        };\n\n        FDate.month = function month(d) {\n            return FDate.__getValue(d, \"Month\") + 1;\n        };\n\n        FDate.second = function second(d) {\n            return FDate.__getValue(d, \"Seconds\");\n        };\n\n        FDate.year = function year(d) {\n            return FDate.__getValue(d, \"FullYear\");\n        };\n\n        FDate.ticks = function ticks(d) {\n            return (d.getTime() + 6.2135604e+13 /* millisecondsJSOffset */) * 10000;\n        };\n\n        FDate.dayOfWeek = function dayOfWeek(d) {\n            return FDate.__getValue(d, \"Day\");\n        };\n\n        FDate.dayOfYear = function dayOfYear(d) {\n            var year = FDate.year(d);\n            var month = FDate.month(d);\n            var day = FDate.day(d);\n            for (var i = 1; i < month; i++) {\n                day += FDate.daysInMonth(year, i);\n            }return day;\n        };\n\n        FDate.add = function add(d, ts) {\n            return FDate.parse(d.getTime() + ts, d.kind);\n        };\n\n        FDate.addDays = function addDays(d, v) {\n            return FDate.parse(d.getTime() + v * 86400000, d.kind);\n        };\n\n        FDate.addHours = function addHours(d, v) {\n            return FDate.parse(d.getTime() + v * 3600000, d.kind);\n        };\n\n        FDate.addMinutes = function addMinutes(d, v) {\n            return FDate.parse(d.getTime() + v * 60000, d.kind);\n        };\n\n        FDate.addSeconds = function addSeconds(d, v) {\n            return FDate.parse(d.getTime() + v * 1000, d.kind);\n        };\n\n        FDate.addMilliseconds = function addMilliseconds(d, v) {\n            return FDate.parse(d.getTime() + v, d.kind);\n        };\n\n        FDate.addTicks = function addTicks(d, v) {\n            return FDate.parse(d.getTime() + v / 10000, d.kind);\n        };\n\n        FDate.addYears = function addYears(d, v) {\n            var newMonth = FDate.month(d);\n            var newYear = FDate.year(d) + v;\n            var daysInMonth = FDate.daysInMonth(newYear, newMonth);\n            var newDay = Math.min(daysInMonth, FDate.day(d));\n            return FDate.create(newYear, newMonth, newDay, FDate.hour(d), FDate.minute(d), FDate.second(d), FDate.millisecond(d), d.kind);\n        };\n\n        FDate.addMonths = function addMonths(d, v) {\n            var newMonth = FDate.month(d) + v;\n            var newMonth_ = 0;\n            var yearOffset = 0;\n            if (newMonth > 12) {\n                newMonth_ = newMonth % 12;\n                yearOffset = Math.floor(newMonth / 12);\n                newMonth = newMonth_;\n            } else if (newMonth < 1) {\n                newMonth_ = 12 + newMonth % 12;\n                yearOffset = Math.floor(newMonth / 12) + (newMonth_ == 12 ? -1 : 0);\n                newMonth = newMonth_;\n            }\n            var newYear = FDate.year(d) + yearOffset;\n            var daysInMonth = FDate.daysInMonth(newYear, newMonth);\n            var newDay = Math.min(daysInMonth, FDate.day(d));\n            return FDate.create(newYear, newMonth, newDay, FDate.hour(d), FDate.minute(d), FDate.second(d), FDate.millisecond(d), d.kind);\n        };\n\n        FDate.subtract = function subtract(d, that) {\n            return typeof that == \"number\" ? FDate.parse(d.getTime() - that, d.kind) : d.getTime() - that.getTime();\n        };\n\n        FDate.toLongDateString = function toLongDateString(d) {\n            return d.toDateString();\n        };\n\n        FDate.toShortDateString = function toShortDateString(d) {\n            return d.toLocaleDateString();\n        };\n\n        FDate.toLongTimeString = function toLongTimeString(d) {\n            return d.toLocaleTimeString();\n        };\n\n        FDate.toShortTimeString = function toShortTimeString(d) {\n            return d.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\n        };\n\n        FDate.equals = function equals(d1, d2) {\n            return d1.getTime() == d2.getTime();\n        };\n\n        return FDate;\n    }(Date);\n\n    FDate.now = FDate.parse;\n    FDate.toBinary = FDate.ticks;\n    FDate.compareTo = Util.compare;\n    FDate.compare = Util.compare;\n    FDate.op_Addition = FDate.add;\n    FDate.op_Subtraction = FDate.subtract;\n    exports.Date = FDate;\n\n    var Timer = exports.Timer = function () {\n        function Timer(interval) {\n            _classCallCheck(this, Timer);\n\n            this.Interval = interval > 0 ? interval : 100;\n            this.AutoReset = true;\n            this._elapsed = new Event();\n        }\n\n        Timer.prototype.Dispose = function Dispose() {\n            this.Enabled = false;\n            this._isDisposed = true;\n        };\n\n        Timer.prototype.Close = function Close() {\n            this.Dispose();\n        };\n\n        Timer.prototype.Start = function Start() {\n            this.Enabled = true;\n        };\n\n        Timer.prototype.Stop = function Stop() {\n            this.Enabled = false;\n        };\n\n        _createClass(Timer, [{\n            key: \"Elapsed\",\n            get: function get() {\n                return this._elapsed;\n            }\n        }, {\n            key: \"Enabled\",\n            get: function get() {\n                return this._enabled;\n            },\n            set: function set(x) {\n                var _this3 = this;\n\n                if (!this._isDisposed && this._enabled != x) {\n                    if (this._enabled = x) {\n                        if (this.AutoReset) {\n                            this._intervalId = setInterval(function () {\n                                if (!_this3.AutoReset) _this3.Enabled = false;\n                                _this3._elapsed.Trigger(new Date());\n                            }, this.Interval);\n                        } else {\n                            this._timeoutId = setTimeout(function () {\n                                _this3.Enabled = false;\n                                _this3._timeoutId = 0;\n                                if (_this3.AutoReset) _this3.Enabled = true;\n                                _this3._elapsed.Trigger(new Date());\n                            }, this.Interval);\n                        }\n                    } else {\n                        if (this._timeoutId) {\n                            clearTimeout(this._timeoutId);\n                            this._timeoutId = 0;\n                        }\n                        if (this._intervalId) {\n                            clearInterval(this._intervalId);\n                            this._intervalId = 0;\n                        }\n                    }\n                }\n            }\n        }]);\n\n        return Timer;\n    }();\n\n    Util.setInterfaces(Timer.prototype, [\"System.IDisposable\"]);\n\n    var FString = function () {\n        function FString() {\n            _classCallCheck(this, FString);\n        }\n\n        FString.fsFormat = function fsFormat(str) {\n            function isObject(x) {\n                return x !== null && (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && !(x instanceof Number) && !(x instanceof String) && !(x instanceof Boolean);\n            }\n            function formatOnce(str, rep) {\n                return str.replace(FString.fsFormatRegExp, function (_, prefix, flags, pad, precision, format) {\n                    switch (format) {\n                        case \"f\":\n                        case \"F\":\n                            rep = rep.toFixed(precision || 6);\n                            break;\n                        case \"g\":\n                        case \"G\":\n                            rep = rep.toPrecision(precision);\n                            break;\n                        case \"e\":\n                        case \"E\":\n                            rep = rep.toExponential(precision);\n                            break;\n                        case \"O\":\n                            rep = Util.toString(rep);\n                            break;\n                        case \"A\":\n                            try {\n                                rep = JSON.stringify(rep, function (k, v) {\n                                    return v && v[Symbol.iterator] && !Array.isArray(v) && isObject(v) ? Array.from(v) : v;\n                                });\n                            } catch (err) {\n                                // Fallback for objects with circular references\n                                rep = \"{\" + Object.getOwnPropertyNames(rep).map(function (k) {\n                                    return k + \": \" + String(rep[k]);\n                                }).join(\", \") + \"}\";\n                            }\n                            break;\n                    }\n                    var plusPrefix = flags.indexOf(\"+\") >= 0 && parseInt(rep) >= 0;\n                    if (!isNaN(pad = parseInt(pad))) {\n                        var ch = pad >= 0 && flags.indexOf(\"0\") >= 0 ? \"0\" : \" \";\n                        rep = FString.padLeft(rep, Math.abs(pad) - (plusPrefix ? 1 : 0), ch, pad < 0);\n                    }\n                    var once = prefix + (plusPrefix ? \"+\" + rep : rep);\n                    return once.replace(/%/g, \"%%\");\n                });\n            }\n            function makeFn(str) {\n                return function (rep) {\n                    var str2 = formatOnce(str, rep);\n                    return FString.fsFormatRegExp.test(str2) ? makeFn(str2) : _cont(str2.replace(/%%/g, \"%\"));\n                };\n            }\n            var _cont = void 0;\n            return function (cont) {\n                _cont = cont;\n                return FString.fsFormatRegExp.test(str) ? makeFn(str) : _cont(str);\n            };\n        };\n\n        FString.format = function format(str) {\n            for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                args[_key3 - 1] = arguments[_key3];\n            }\n\n            return str.replace(FString.formatRegExp, function (match, idx, pad, format) {\n                var rep = args[idx],\n                    padSymbol = \" \";\n                if (typeof rep === \"number\") {\n                    switch ((format || \"\").substring(0, 1)) {\n                        case \"f\":\n                        case \"F\":\n                            rep = format.length > 1 ? rep.toFixed(format.substring(1)) : rep.toFixed(2);\n                            break;\n                        case \"g\":\n                        case \"G\":\n                            rep = format.length > 1 ? rep.toPrecision(format.substring(1)) : rep.toPrecision();\n                            break;\n                        case \"e\":\n                        case \"E\":\n                            rep = format.length > 1 ? rep.toExponential(format.substring(1)) : rep.toExponential();\n                            break;\n                        case \"p\":\n                        case \"P\":\n                            rep = (format.length > 1 ? (rep * 100).toFixed(format.substring(1)) : (rep * 100).toFixed(2)) + \" %\";\n                            break;\n                        default:\n                            var m = /^(0+)(\\.0+)?$/.exec(format);\n                            if (m != null) {\n                                var decs = 0;\n                                if (m[2] != null) rep = rep.toFixed(decs = m[2].length - 1);\n                                pad = \",\" + (m[1].length + (decs ? decs + 1 : 0)).toString();\n                                padSymbol = \"0\";\n                            } else if (format) {\n                                rep = format;\n                            }\n                    }\n                } else if (rep instanceof Date) {\n                    if (format.length === 1) {\n                        switch (format) {\n                            case \"D\":\n                                rep = rep.toDateString();\n                                break;\n                            case \"T\":\n                                rep = rep.toLocaleTimeString();\n                                break;\n                            case \"d\":\n                                rep = rep.toLocaleDateString();\n                                break;\n                            case \"t\":\n                                rep = rep.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\n                                break;\n                            case \"o\":\n                            case \"O\":\n                                if (rep.kind === DateKind.Local) {\n                                    var offset = rep.getTimezoneOffset() * -1;\n                                    rep = FString.format(\"{0:yyyy-MM-dd}T{0:HH:mm}:{1:00.000}{2}{3:00}:{4:00}\", rep, FDate.second(rep), offset >= 0 ? \"+\" : \"-\", ~~(offset / 60), offset % 60);\n                                } else {\n                                    rep = rep.toISOString();\n                                }\n                        }\n                    } else {\n                        rep = format.replace(/\\w+/g, function (match2) {\n                            var rep2 = match2;\n                            switch (match2.substring(0, 1)) {\n                                case \"y\":\n                                    rep2 = match2.length < 4 ? FDate.year(rep) % 100 : FDate.year(rep);\n                                    break;\n                                case \"h\":\n                                    rep2 = rep.getHours() > 12 ? FDate.hour(rep) % 12 : FDate.hour(rep);\n                                    break;\n                                case \"M\":\n                                    rep2 = FDate.month(rep);\n                                    break;\n                                case \"d\":\n                                    rep2 = FDate.day(rep);\n                                    break;\n                                case \"H\":\n                                    rep2 = FDate.hour(rep);\n                                    break;\n                                case \"m\":\n                                    rep2 = FDate.minute(rep);\n                                    break;\n                                case \"s\":\n                                    rep2 = FDate.second(rep);\n                                    break;\n                            }\n                            if (rep2 !== match2 && rep2 < 10 && match2.length > 1) {\n                                rep2 = \"0\" + rep2;\n                            }\n                            return rep2;\n                        });\n                    }\n                }\n                if (!isNaN(pad = parseInt((pad || \"\").substring(1)))) {\n                    rep = FString.padLeft(rep, Math.abs(pad), padSymbol, pad < 0);\n                }\n                return rep;\n            });\n        };\n\n        FString.endsWith = function endsWith(str, search) {\n            var idx = str.lastIndexOf(search);\n            return idx >= 0 && idx == str.length - search.length;\n        };\n\n        FString.initialize = function initialize(n, f) {\n            if (n < 0) throw \"String length must be non-negative\";\n            var xs = new Array(n);\n            for (var i = 0; i < n; i++) {\n                xs[i] = f(i);\n            }return xs.join(\"\");\n        };\n\n        FString.isNullOrEmpty = function isNullOrEmpty(str) {\n            return typeof str !== \"string\" || str.length == 0;\n        };\n\n        FString.isNullOrWhiteSpace = function isNullOrWhiteSpace(str) {\n            return typeof str !== \"string\" || /^\\s*$/.test(str);\n        };\n\n        FString.join = function join(delimiter, xs) {\n            xs = typeof xs == \"string\" ? Util.getRestParams(arguments, 1) : xs;\n            return (Array.isArray(xs) ? xs : Array.from(xs)).join(delimiter);\n        };\n\n        FString.newGuid = function newGuid() {\n            var uuid = \"\";\n            for (var i = 0; i < 32; i++) {\n                var random = Math.random() * 16 | 0;\n                if (i === 8 || i === 12 || i === 16 || i === 20) uuid += \"-\";\n                uuid += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\n            }\n            return uuid;\n        };\n\n        FString.padLeft = function padLeft(str, len, ch, isRight) {\n            ch = ch || \" \";\n            str = String(str);\n            len = len - str.length;\n            for (var i = -1; ++i < len;) {\n                str = isRight ? str + ch : ch + str;\n            }return str;\n        };\n\n        FString.padRight = function padRight(str, len, ch) {\n            return FString.padLeft(str, len, ch, true);\n        };\n\n        FString.replace = function replace(str, search, _replace) {\n            return str.replace(new RegExp(FRegExp.escape(search), \"g\"), _replace);\n        };\n\n        FString.replicate = function replicate(n, x) {\n            return FString.initialize(n, function () {\n                return x;\n            });\n        };\n\n        FString.split = function split(str, splitters, count, removeEmpty) {\n            count = typeof count == \"number\" ? count : null;\n            removeEmpty = typeof removeEmpty == \"number\" ? removeEmpty : null;\n            if (count < 0) throw \"Count cannot be less than zero\";\n            if (count === 0) return [];\n            splitters = Array.isArray(splitters) ? splitters : Util.getRestParams(arguments, 1);\n            splitters = splitters.map(function (x) {\n                return FRegExp.escape(x);\n            });\n            splitters = splitters.length > 0 ? splitters : [\" \"];\n            var m = void 0;\n            var i = 0;\n            var splits = [];\n            var reg = new RegExp(splitters.join(\"|\"), \"g\");\n            while ((count == null || count > 1) && (m = reg.exec(str)) !== null) {\n                if (!removeEmpty || m.index - i > 0) {\n                    count = count != null ? count - 1 : count;\n                    splits.push(str.substring(i, m.index));\n                }\n                i = reg.lastIndex;\n            }\n            if (!removeEmpty || str.length - i > 0) splits.push(str.substring(i));\n            return splits;\n        };\n\n        FString.trim = function trim(str, side) {\n            for (var _len4 = arguments.length, chars = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n                chars[_key4 - 2] = arguments[_key4];\n            }\n\n            if (side == \"both\" && chars.length == 0) return str.trim();\n            if (side == \"start\" || side == \"both\") {\n                var reg = chars.length == 0 ? /^\\s+/ : new RegExp(\"^[\" + FRegExp.escape(chars.join(\"\")) + \"]+\");\n                str = str.replace(reg, \"\");\n            }\n            if (side == \"end\" || side == \"both\") {\n                var _reg = chars.length == 0 ? /\\s+$/ : new RegExp(\"[\" + FRegExp.escape(chars.join(\"\")) + \"]+$\");\n                str = str.replace(_reg, \"\");\n            }\n            return str;\n        };\n\n        return FString;\n    }();\n\n    FString.fsFormatRegExp = /(^|[^%])%([0+ ]*)(-?\\d+)?(?:\\.(\\d+))?(\\w)/;\n    FString.formatRegExp = /\\{(\\d+)(,-?\\d+)?(?:\\:(.+?))?\\}/g;\n    exports.String = FString;\n\n    var FRegExp = function () {\n        function FRegExp() {\n            _classCallCheck(this, FRegExp);\n        }\n\n        FRegExp.create = function create(pattern, options) {\n            var flags = \"g\";\n            flags += options & 1 ? \"i\" : \"\";\n            flags += options & 2 ? \"m\" : \"\";\n            return new RegExp(pattern, flags);\n        };\n\n        FRegExp.escape = function escape(str) {\n            return str.replace(/[\\-\\[\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n        };\n\n        FRegExp.unescape = function unescape(str) {\n            return str.replace(/\\\\([\\-\\[\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|])/g, \"$1\");\n        };\n\n        FRegExp.isMatch = function isMatch(str, pattern) {\n            var options = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n            var reg = str instanceof RegExp ? (reg = str, str = pattern, reg.lastIndex = options, reg) : reg = FRegExp.create(pattern, options);\n            return reg.test(str);\n        };\n\n        FRegExp.match = function match(str, pattern) {\n            var options = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n            var reg = str instanceof RegExp ? (reg = str, str = pattern, reg.lastIndex = options, reg) : reg = FRegExp.create(pattern, options);\n            return reg.exec(str);\n        };\n\n        FRegExp.matches = function matches(str, pattern) {\n            var options = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n            var reg = str instanceof RegExp ? (reg = str, str = pattern, reg.lastIndex = options, reg) : reg = FRegExp.create(pattern, options);\n            if (!reg.global) throw \"Non-global RegExp\"; // Prevent infinite loop\n            var m = void 0;\n            var matches = [];\n            while ((m = reg.exec(str)) !== null) {\n                matches.push(m);\n            }return matches;\n        };\n\n        FRegExp.options = function options(reg) {\n            var options = 256; // ECMAScript\n            options |= reg.ignoreCase ? 1 : 0;\n            options |= reg.multiline ? 2 : 0;\n            return options;\n        };\n\n        FRegExp.replace = function replace(reg, input, replacement, limit) {\n            var offset = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];\n\n            function replacer() {\n                var res = arguments[0];\n                if (limit !== 0) {\n                    limit--;\n                    var match = [];\n                    var len = arguments.length;\n                    for (var i = 0; i < len - 2; i++) {\n                        match.push(arguments[i]);\n                    }match.index = arguments[len - 2];\n                    match.input = arguments[len - 1];\n                    res = replacement(match);\n                }\n                return res;\n            }\n            if (typeof reg == \"string\") {\n                var tmp = reg;\n                reg = FRegExp.create(input, limit);\n                input = tmp;\n                limit = undefined;\n            }\n            if (typeof replacement == \"function\") {\n                limit = limit == null ? -1 : limit;\n                return input.substring(0, offset) + input.substring(offset).replace(reg, replacer);\n            } else {\n                if (limit != null) {\n                    var m = void 0;\n                    var sub1 = input.substring(offset);\n                    var matches = FRegExp.matches(reg, sub1);\n                    var sub2 = matches.length > limit ? (m = matches[limit - 1], sub1.substring(0, m.index + m[0].length)) : sub1;\n                    return input.substring(0, offset) + sub2.replace(reg, replacement) + input.substring(offset + sub2.length);\n                } else {\n                    return input.replace(reg, replacement);\n                }\n            }\n        };\n\n        FRegExp.split = function split(reg, input, limit) {\n            var offset = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n\n            if (typeof reg == \"string\") {\n                var tmp = reg;\n                reg = FRegExp.create(input, limit);\n                input = tmp;\n                limit = undefined;\n            }\n            input = input.substring(offset);\n            return input.split(reg, limit);\n        };\n\n        return FRegExp;\n    }();\n\n    exports.RegExp = FRegExp;\n\n    var FArray = function () {\n        function FArray() {\n            _classCallCheck(this, FArray);\n        }\n\n        FArray.addRangeInPlace = function addRangeInPlace(range, xs) {\n            Seq.iterate(function (x) {\n                return xs.push(x);\n            }, range);\n        };\n\n        FArray.copyTo = function copyTo(source, sourceIndex, target, targetIndex, count) {\n            while (count--) {\n                target[targetIndex++] = source[sourceIndex++];\n            }\n        };\n\n        FArray.partition = function partition(f, xs) {\n            var ys = [],\n                zs = [],\n                j = 0,\n                k = 0;\n            for (var i = 0; i < xs.length; i++) {\n                if (f(xs[i])) ys[j++] = xs[i];else zs[k++] = xs[i];\n            }return Tuple(ys, zs);\n        };\n\n        FArray.permute = function permute(f, xs) {\n            // Keep the type of the array\n            var ys = xs.map(function () {\n                return null;\n            });\n            var checkFlags = new Array(xs.length);\n            for (var i = 0; i < xs.length; i++) {\n                var j = f(i);\n                if (j < 0 || j >= xs.length) throw \"Not a valid permutation\";\n                ys[j] = xs[i];\n                checkFlags[j] = 1;\n            }\n            for (var _i2 = 0; _i2 < xs.length; _i2++) {\n                if (checkFlags[_i2] != 1) throw \"Not a valid permutation\";\n            }return ys;\n        };\n\n        FArray.removeInPlace = function removeInPlace(item, xs) {\n            var i = xs.indexOf(item);\n            if (i > -1) {\n                xs.splice(i, 1);\n                return true;\n            }\n            return false;\n        };\n\n        FArray.setSlice = function setSlice(target, lower, upper, source) {\n            var length = (upper || target.length - 1) - lower;\n            if (ArrayBuffer.isView(target) && source.length <= length) target.set(source, lower);else for (var i = lower | 0, j = 0; j <= length; i++, j++) {\n                target[i] = source[j];\n            }\n        };\n\n        FArray.sortInPlaceBy = function sortInPlaceBy(f, xs) {\n            var dir = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n\n            return xs.sort(function (x, y) {\n                x = f(x);\n                y = f(y);\n                return (x < y ? -1 : x == y ? 0 : 1) * dir;\n            });\n        };\n\n        FArray.unzip = function unzip(xs) {\n            var bs = new Array(xs.length),\n                cs = new Array(xs.length);\n            for (var i = 0; i < xs.length; i++) {\n                bs[i] = xs[i][0];\n                cs[i] = xs[i][1];\n            }\n            return Tuple(bs, cs);\n        };\n\n        FArray.unzip3 = function unzip3(xs) {\n            var bs = new Array(xs.length),\n                cs = new Array(xs.length),\n                ds = new Array(xs.length);\n            for (var i = 0; i < xs.length; i++) {\n                bs[i] = xs[i][0];\n                cs[i] = xs[i][1];\n                ds[i] = xs[i][2];\n            }\n            return Tuple3(bs, cs, ds);\n        };\n\n        return FArray;\n    }();\n\n    exports.Array = FArray;\n\n    var List = exports.List = function () {\n        function List(head, tail) {\n            _classCallCheck(this, List);\n\n            this.head = head;\n            this.tail = tail;\n        }\n\n        List.prototype.ToString = function ToString() {\n            return \"[\" + Array.from(this).map(Util.toString).join(\"; \") + \"]\";\n        };\n\n        List.prototype.Equals = function Equals(x) {\n            var iter1 = this[Symbol.iterator](),\n                iter2 = x[Symbol.iterator]();\n            for (var i = 0;; i++) {\n                var cur1 = iter1.next(),\n                    cur2 = iter2.next();\n                if (cur1.done) return cur2.done ? true : false;else if (cur2.done) return false;else if (!Util.equals(cur1.value, cur2.value)) return false;\n            }\n        };\n\n        List.prototype.CompareTo = function CompareTo(x) {\n            var acc = 0;\n            var iter1 = this[Symbol.iterator](),\n                iter2 = x[Symbol.iterator]();\n            for (var i = 0;; i++) {\n                var cur1 = iter1.next(),\n                    cur2 = iter2.next();\n                if (cur1.done) return cur2.done ? acc : -1;else if (cur2.done) return 1;else {\n                    acc = Util.compare(cur1.value, cur2.value);\n                    if (acc != 0) return acc;\n                }\n            }\n        };\n\n        List.ofArray = function ofArray(args, base) {\n            var acc = base || new List();\n            for (var i = args.length - 1; i >= 0; i--) {\n                acc = new List(args[i], acc);\n            }\n            return acc;\n        };\n\n        List.prototype[Symbol.iterator] = function () {\n            var cur = this;\n            return {\n                next: function next() {\n                    var tmp = cur;\n                    cur = cur.tail;\n                    return { done: tmp.tail == null, value: tmp.head };\n                }\n            };\n        };\n\n        List.prototype.append = function append(ys) {\n            return List.append(this, ys);\n        };\n\n        List.append = function append(xs, ys) {\n            return Seq.fold(function (acc, x) {\n                return new List(x, acc);\n            }, ys, List.reverse(xs));\n        };\n\n        List.prototype.choose = function choose(f, xs) {\n            return List.choose(f, this);\n        };\n\n        List.choose = function choose(f, xs) {\n            var r = Seq.fold(function (acc, x) {\n                var y = f(x);\n                return y != null ? new List(y, acc) : acc;\n            }, new List(), xs);\n            return List.reverse(r);\n        };\n\n        List.prototype.collect = function collect(f) {\n            return List.collect(f, this);\n        };\n\n        List.collect = function collect(f, xs) {\n            return Seq.fold(function (acc, x) {\n                return acc.append(f(x));\n            }, new List(), xs);\n        };\n        // TODO: should be xs: Iterable<List<T>>\n\n\n        List.concat = function concat(xs) {\n            return List.collect(function (x) {\n                return x;\n            }, xs);\n        };\n\n        List.prototype.filter = function filter(f) {\n            return List.filter(f, this);\n        };\n\n        List.filter = function filter(f, xs) {\n            return List.reverse(Seq.fold(function (acc, x) {\n                return f(x) ? new List(x, acc) : acc;\n            }, new List(), xs));\n        };\n\n        List.prototype.where = function where(f) {\n            return List.filter(f, this);\n        };\n\n        List.where = function where(f, xs) {\n            return List.filter(f, xs);\n        };\n\n        List.initialize = function initialize(n, f) {\n            if (n < 0) {\n                throw \"List length must be non-negative\";\n            }\n            var xs = new List();\n            for (var i = 1; i <= n; i++) {\n                xs = new List(f(n - i), xs);\n            }\n            return xs;\n        };\n\n        List.prototype.map = function map(f) {\n            return List.map(f, this);\n        };\n\n        List.map = function map(f, xs) {\n            return List.reverse(Seq.fold(function (acc, x) {\n                return new List(f(x), acc);\n            }, new List(), xs));\n        };\n\n        List.prototype.mapIndexed = function mapIndexed(f) {\n            return List.mapIndexed(f, this);\n        };\n\n        List.mapIndexed = function mapIndexed(f, xs) {\n            return List.reverse(Seq.fold(function (acc, x, i) {\n                return new List(f(i, x), acc);\n            }, new List(), xs));\n        };\n\n        List.prototype.partition = function partition(f) {\n            return List.partition(f, this);\n        };\n\n        List.partition = function partition(f, xs) {\n            return Seq.fold(function (acc, x) {\n                var lacc = acc[0],\n                    racc = acc[1];\n                return f(x) ? Tuple(new List(x, lacc), racc) : Tuple(lacc, new List(x, racc));\n            }, Tuple(new List(), new List()), List.reverse(xs));\n        };\n\n        List.replicate = function replicate(n, x) {\n            return List.initialize(n, function () {\n                return x;\n            });\n        };\n\n        List.prototype.reverse = function reverse() {\n            return List.reverse(this);\n        };\n\n        List.reverse = function reverse(xs) {\n            return Seq.fold(function (acc, x) {\n                return new List(x, acc);\n            }, new List(), xs);\n        };\n\n        List.singleton = function singleton(x) {\n            return new List(x, new List());\n        };\n\n        List.prototype.slice = function slice(lower, upper) {\n            return List.slice(lower, upper, this);\n        };\n\n        List.slice = function slice(lower, upper, xs) {\n            var noLower = lower == null;\n            var noUpper = upper == null;\n            return List.reverse(Seq.fold(function (acc, x, i) {\n                return (noLower || lower <= i) && (noUpper || i <= upper) ? new List(x, acc) : acc;\n            }, new List(), xs));\n        };\n        /* ToDo: instance unzip() */\n\n\n        List.unzip = function unzip(xs) {\n            return Seq.foldBack(function (xy, acc) {\n                return Tuple(new List(xy[0], acc[0]), new List(xy[1], acc[1]));\n            }, xs, Tuple(new List(), new List()));\n        };\n        /* ToDo: instance unzip3() */\n\n\n        List.unzip3 = function unzip3(xs) {\n            return Seq.foldBack(function (xyz, acc) {\n                return Tuple3(new List(xyz[0], acc[0]), new List(xyz[1], acc[1]), new List(xyz[2], acc[2]));\n            }, xs, Tuple3(new List(), new List(), new List()));\n        };\n\n        _createClass(List, [{\n            key: \"length\",\n            get: function get() {\n                return Seq.fold(function (acc, x) {\n                    return acc + 1;\n                }, 0, this);\n            }\n        }]);\n\n        return List;\n    }();\n\n    Util.setInterfaces(List.prototype, [\"System.IEquatable\", \"System.IComparable\"], \"Microsoft.FSharp.Collections.FSharpList\");\n\n    var Seq = exports.Seq = function () {\n        function Seq() {\n            _classCallCheck(this, Seq);\n        }\n\n        Seq.__failIfNone = function __failIfNone(res) {\n            if (res == null) throw \"Seq did not contain any matching element\";\n            return res;\n        };\n\n        Seq.toList = function toList(xs) {\n            return Seq.foldBack(function (x, acc) {\n                return new List(x, acc);\n            }, xs, new List());\n        };\n\n        Seq.ofList = function ofList(xs) {\n            return Seq.delay(function () {\n                return Seq.unfold(function (x) {\n                    return x.tail != null ? [x.head, x.tail] : null;\n                }, xs);\n            });\n        };\n\n        Seq.ofArray = function ofArray(xs) {\n            return Seq.delay(function () {\n                return Seq.unfold(function (i) {\n                    return i < xs.length ? [xs[i], i + 1] : null;\n                }, 0);\n            });\n        };\n\n        Seq.append = function append(xs, ys) {\n            return Seq.delay(function () {\n                var firstDone = false;\n                var i = xs[Symbol.iterator]();\n                var iters = Tuple(i, null);\n                return Seq.unfold(function () {\n                    var cur = void 0;\n                    if (!firstDone) {\n                        cur = iters[0].next();\n                        if (!cur.done) {\n                            return [cur.value, iters];\n                        } else {\n                            firstDone = true;\n                            iters = [null, ys[Symbol.iterator]()];\n                        }\n                    }\n                    cur = iters[1].next();\n                    return !cur.done ? [cur.value, iters] : null;\n                }, iters);\n            });\n        };\n\n        Seq.average = function average(xs) {\n            var count = 1;\n            var sum = Seq.reduce(function (acc, x) {\n                count++;\n                return acc + x;\n            }, xs);\n            return sum / count;\n        };\n\n        Seq.averageBy = function averageBy(f, xs) {\n            var count = 1;\n            var sum = Seq.reduce(function (acc, x) {\n                count++;\n                return (count === 2 ? f(acc) : acc) + f(x);\n            }, xs);\n            return sum / count;\n        };\n\n        Seq.countBy = function countBy(f, xs) {\n            return Seq.map(function (kv) {\n                return Tuple(kv[0], Seq.count(kv[1]));\n            }, Seq.groupBy(f, xs));\n        };\n\n        Seq.concat = function concat(xs) {\n            return Seq.delay(function () {\n                var iter = xs[Symbol.iterator]();\n                var output = null;\n                return Seq.unfold(function (innerIter) {\n                    var hasFinished = false;\n                    while (!hasFinished) {\n                        if (innerIter == null) {\n                            var cur = iter.next();\n                            if (!cur.done) {\n                                innerIter = cur.value[Symbol.iterator]();\n                            } else {\n                                hasFinished = true;\n                            }\n                        } else {\n                            var _cur = innerIter.next();\n                            if (!_cur.done) {\n                                output = _cur.value;\n                                hasFinished = true;\n                            } else {\n                                innerIter = null;\n                            }\n                        }\n                    }\n                    return innerIter != null && output != null ? [output, innerIter] : null;\n                }, null);\n            });\n        };\n\n        Seq.collect = function collect(f, xs) {\n            return Seq.concat(Seq.map(f, xs));\n        };\n\n        Seq.choose = function choose(f, xs) {\n            var trySkipToNext = function trySkipToNext(iter) {\n                var cur = iter.next();\n                if (!cur.done) {\n                    var y = f(cur.value);\n                    return y != null ? Tuple(y, iter) : trySkipToNext(iter);\n                }\n                return void 0;\n            };\n            return Seq.delay(function () {\n                return Seq.unfold(function (iter) {\n                    return trySkipToNext(iter);\n                }, xs[Symbol.iterator]());\n            });\n        };\n\n        Seq.compareWith = function compareWith(f, xs, ys) {\n            var nonZero = Seq.tryFind(function (i) {\n                return i != 0;\n            }, Seq.map2(function (x, y) {\n                return f(x, y);\n            }, xs, ys));\n            return nonZero != null ? nonZero : Seq.count(xs) - Seq.count(ys);\n        };\n\n        Seq.delay = function delay(f) {\n            return _defineProperty({}, Symbol.iterator, function () {\n                return f()[Symbol.iterator]();\n            });\n        };\n\n        Seq.distinctBy = function distinctBy(f, xs) {\n            return Seq.choose(function (tup) {\n                return tup[0];\n            }, Seq.scan(function (tup, x) {\n                var acc = tup[1];\n                var k = f(x);\n                return acc.has(k) ? Tuple(null, acc) : Tuple(x, FSet.add(k, acc));\n            }, Tuple(null, FSet.create()), xs));\n        };\n\n        Seq.distinct = function distinct(xs) {\n            return Seq.distinctBy(function (x) {\n                return x;\n            }, xs);\n        };\n\n        Seq.empty = function empty() {\n            return Seq.unfold(function () {\n                return void 0;\n            });\n        };\n\n        Seq.enumerateWhile = function enumerateWhile(cond, xs) {\n            return Seq.concat(Seq.unfold(function () {\n                return cond() ? [xs, true] : null;\n            }));\n        };\n\n        Seq.enumerateThenFinally = function enumerateThenFinally(xs, finalFn) {\n            return Seq.delay(function () {\n                var iter = void 0;\n                try {\n                    iter = xs[Symbol.iterator]();\n                } finally {\n                    finalFn();\n                }\n                return Seq.unfold(function (iter) {\n                    try {\n                        var cur = iter.next();\n                        return !cur.done ? [cur.value, iter] : null;\n                    } finally {\n                        finalFn();\n                    }\n                    return void 0;\n                }, iter);\n            });\n        };\n\n        Seq.enumerateUsing = function enumerateUsing(disp, work) {\n            var isDisposed = false;\n            var disposeOnce = function disposeOnce() {\n                if (!isDisposed) {\n                    isDisposed = true;\n                    disp.Dispose();\n                }\n            };\n            try {\n                return Seq.enumerateThenFinally(work(disp), disposeOnce);\n            } finally {\n                disposeOnce();\n            }\n            return void 0;\n        };\n\n        Seq.exactlyOne = function exactlyOne(xs) {\n            var iter = xs[Symbol.iterator]();\n            var fst = iter.next();\n            if (fst.done) throw \"Seq was empty\";\n            var snd = iter.next();\n            if (!snd.done) throw \"Seq had multiple items\";\n            return fst.value;\n        };\n\n        Seq.except = function except(itemsToExclude, source) {\n            var exclusionItems = Array.from(itemsToExclude);\n            var testIsNotInExclusionItems = function testIsNotInExclusionItems(element) {\n                return !exclusionItems.some(function (excludedItem) {\n                    return Util.equals(excludedItem, element);\n                });\n            };\n            return Seq.filter(testIsNotInExclusionItems, source);\n        };\n\n        Seq.exists = function exists(f, xs) {\n            function aux(iter) {\n                var cur = iter.next();\n                return !cur.done && (f(cur.value) || aux(iter));\n            }\n            return aux(xs[Symbol.iterator]());\n        };\n\n        Seq.exists2 = function exists2(f, xs, ys) {\n            function aux(iter1, iter2) {\n                var cur1 = iter1.next(),\n                    cur2 = iter2.next();\n                return !cur1.done && !cur2.done && (f(cur1.value, cur2.value) || aux(iter1, iter2));\n            }\n            return aux(xs[Symbol.iterator](), ys[Symbol.iterator]());\n        };\n\n        Seq.filter = function filter(f, xs) {\n            function trySkipToNext(iter) {\n                var cur = iter.next();\n                if (!cur.done) return f(cur.value) ? [cur.value, iter] : trySkipToNext(iter);\n                return void 0;\n            }\n            return Seq.delay(function () {\n                return Seq.unfold(trySkipToNext, xs[Symbol.iterator]());\n            });\n        };\n\n        Seq.where = function where(f, xs) {\n            return Seq.filter(f, xs);\n        };\n\n        Seq.fold = function fold(f, acc, xs) {\n            if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\n                return xs.reduce(f, acc);\n            } else {\n                var cur = void 0;\n                for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n                    cur = iter.next();\n                    if (cur.done) break;\n                    acc = f(acc, cur.value, i);\n                }\n                return acc;\n            }\n        };\n\n        Seq.foldBack = function foldBack(f, xs, acc) {\n            var arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n            for (var i = arr.length - 1; i >= 0; i--) {\n                acc = f(arr[i], acc, i);\n            }\n            return acc;\n        };\n\n        Seq.fold2 = function fold2(f, acc, xs, ys) {\n            var iter1 = xs[Symbol.iterator](),\n                iter2 = ys[Symbol.iterator]();\n            var cur1 = void 0,\n                cur2 = void 0;\n            for (var i = 0;; i++) {\n                cur1 = iter1.next();\n                cur2 = iter2.next();\n                if (cur1.done || cur2.done) {\n                    break;\n                }\n                acc = f(acc, cur1.value, cur2.value, i);\n            }\n            return acc;\n        };\n\n        Seq.foldBack2 = function foldBack2(f, xs, ys, acc) {\n            var ar1 = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n            var ar2 = Array.isArray(ys) || ArrayBuffer.isView(ys) ? ys : Array.from(ys);\n            for (var i = ar1.length - 1; i >= 0; i--) {\n                acc = f(ar1[i], ar2[i], acc, i);\n            }\n            return acc;\n        };\n\n        Seq.forAll = function forAll(f, xs) {\n            return Seq.fold(function (acc, x) {\n                return acc && f(x);\n            }, true, xs);\n        };\n\n        Seq.forAll2 = function forAll2(f, xs, ys) {\n            return Seq.fold2(function (acc, x, y) {\n                return acc && f(x, y);\n            }, true, xs, ys);\n        };\n        // TODO: Should return a Iterable<Tuple<K, Iterable<T>>> instead of a Map<K, Iterable<T>>\n        // Seq.groupBy : ('T -> 'Key) -> seq<'T> -> seq<'Key * seq<'T>>\n\n\n        Seq.groupBy = function groupBy(f, xs) {\n            var keys = [];\n            var map = Seq.fold(function (acc, x) {\n                var k = f(x),\n                    vs = FMap.tryFind(k, acc);\n                if (vs == null) {\n                    keys.push(k);\n                    return FMap.add(k, [x], acc);\n                } else {\n                    vs.push(x);\n                    return acc;\n                }\n            }, FMap.create(), xs);\n            return keys.map(function (k) {\n                return [k, map.get(k)];\n            });\n        };\n\n        Seq.tryHead = function tryHead(xs) {\n            var iter = xs[Symbol.iterator]();\n            var cur = iter.next();\n            return cur.done ? null : cur.value;\n        };\n\n        Seq.head = function head(xs) {\n            return Seq.__failIfNone(Seq.tryHead(xs));\n        };\n\n        Seq.initialize = function initialize(n, f) {\n            return Seq.delay(function () {\n                return Seq.unfold(function (i) {\n                    return i < n ? [f(i), i + 1] : null;\n                }, 0);\n            });\n        };\n\n        Seq.initializeInfinite = function initializeInfinite(f) {\n            return Seq.delay(function () {\n                return Seq.unfold(function (i) {\n                    return [f(i), i + 1];\n                }, 0);\n            });\n        };\n\n        Seq.tryItem = function tryItem(i, xs) {\n            if (i < 0) return null;\n            if (Array.isArray(xs) || ArrayBuffer.isView(xs)) return i < xs.length ? xs[i] : null;\n            for (var j = 0, iter = xs[Symbol.iterator]();; j++) {\n                var cur = iter.next();\n                if (cur.done) return null;\n                if (j === i) return cur.value;\n            }\n        };\n\n        Seq.item = function item(i, xs) {\n            return Seq.__failIfNone(Seq.tryItem(i, xs));\n        };\n\n        Seq.iterate = function iterate(f, xs) {\n            Seq.fold(function (_, x) {\n                return f(x);\n            }, null, xs);\n        };\n\n        Seq.iterate2 = function iterate2(f, xs, ys) {\n            Seq.fold2(function (_, x, y) {\n                return f(x, y);\n            }, null, xs, ys);\n        };\n\n        Seq.iterateIndexed = function iterateIndexed(f, xs) {\n            Seq.fold(function (_, x, i) {\n                return f(i, x);\n            }, null, xs);\n        };\n\n        Seq.iterateIndexed2 = function iterateIndexed2(f, xs, ys) {\n            Seq.fold2(function (_, x, y, i) {\n                return f(i, x, y);\n            }, null, xs, ys);\n        };\n\n        Seq.isEmpty = function isEmpty(xs) {\n            var i = xs[Symbol.iterator]();\n            return i.next().done;\n        };\n\n        Seq.tryLast = function tryLast(xs) {\n            try {\n                return Seq.reduce(function (_, x) {\n                    return x;\n                }, xs);\n            } catch (err) {\n                return null;\n            }\n        };\n\n        Seq.last = function last(xs) {\n            return Seq.__failIfNone(Seq.tryLast(xs));\n        };\n        // A static 'length' method causes problems in JavaScript -- https://github.com/Microsoft/TypeScript/issues/442\n\n\n        Seq.count = function count(xs) {\n            return Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.length : Seq.fold(function (acc, x) {\n                return acc + 1;\n            }, 0, xs);\n        };\n\n        Seq.map = function map(f, xs) {\n            return Seq.delay(function () {\n                return Seq.unfold(function (iter) {\n                    var cur = iter.next();\n                    return !cur.done ? [f(cur.value), iter] : null;\n                }, xs[Symbol.iterator]());\n            });\n        };\n\n        Seq.mapIndexed = function mapIndexed(f, xs) {\n            return Seq.delay(function () {\n                var i = 0;\n                return Seq.unfold(function (iter) {\n                    var cur = iter.next();\n                    return !cur.done ? [f(i++, cur.value), iter] : null;\n                }, xs[Symbol.iterator]());\n            });\n        };\n\n        Seq.map2 = function map2(f, xs, ys) {\n            return Seq.delay(function () {\n                var iter1 = xs[Symbol.iterator]();\n                var iter2 = ys[Symbol.iterator]();\n                return Seq.unfold(function () {\n                    var cur1 = iter1.next(),\n                        cur2 = iter2.next();\n                    return !cur1.done && !cur2.done ? [f(cur1.value, cur2.value), null] : null;\n                });\n            });\n        };\n\n        Seq.mapIndexed2 = function mapIndexed2(f, xs, ys) {\n            return Seq.delay(function () {\n                var i = 0;\n                var iter1 = xs[Symbol.iterator]();\n                var iter2 = ys[Symbol.iterator]();\n                return Seq.unfold(function () {\n                    var cur1 = iter1.next(),\n                        cur2 = iter2.next();\n                    return !cur1.done && !cur2.done ? [f(i++, cur1.value, cur2.value), null] : null;\n                });\n            });\n        };\n\n        Seq.map3 = function map3(f, xs, ys, zs) {\n            return Seq.delay(function () {\n                var iter1 = xs[Symbol.iterator]();\n                var iter2 = ys[Symbol.iterator]();\n                var iter3 = zs[Symbol.iterator]();\n                return Seq.unfold(function () {\n                    var cur1 = iter1.next(),\n                        cur2 = iter2.next(),\n                        cur3 = iter3.next();\n                    return !cur1.done && !cur2.done && !cur3.done ? [f(cur1.value, cur2.value, cur3.value), null] : null;\n                });\n            });\n        };\n\n        Seq.mapFold = function mapFold(f, acc, xs) {\n            var result = [];\n            var r = void 0;\n            var cur = void 0;\n            for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n                cur = iter.next();\n                if (cur.done) break;\n\n                var _f = f(acc, cur.value);\n\n                var _f2 = _slicedToArray(_f, 2);\n\n                r = _f2[0];\n                acc = _f2[1];\n\n                result.push(r);\n            }\n            return Tuple(result, acc);\n        };\n\n        Seq.mapFoldBack = function mapFoldBack(f, xs, acc) {\n            var arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n            var result = [];\n            var r = void 0;\n            for (var i = arr.length - 1; i >= 0; i--) {\n                var _f3 = f(arr[i], acc);\n\n                var _f4 = _slicedToArray(_f3, 2);\n\n                r = _f4[0];\n                acc = _f4[1];\n\n                result.push(r);\n            }\n            return Tuple(result, acc);\n        };\n\n        Seq.max = function max(xs) {\n            return Seq.reduce(function (acc, x) {\n                return Util.compare(acc, x) === 1 ? acc : x;\n            }, xs);\n        };\n\n        Seq.maxBy = function maxBy(f, xs) {\n            return Seq.reduce(function (acc, x) {\n                return Util.compare(f(acc), f(x)) === 1 ? acc : x;\n            }, xs);\n        };\n\n        Seq.min = function min(xs) {\n            return Seq.reduce(function (acc, x) {\n                return Util.compare(acc, x) === -1 ? acc : x;\n            }, xs);\n        };\n\n        Seq.minBy = function minBy(f, xs) {\n            return Seq.reduce(function (acc, x) {\n                return Util.compare(f(acc), f(x)) === -1 ? acc : x;\n            }, xs);\n        };\n\n        Seq.pairwise = function pairwise(xs) {\n            return Seq.skip(2, Seq.scan(function (last, next) {\n                return Tuple(last[1], next);\n            }, Tuple(0, 0), xs));\n        };\n\n        Seq.permute = function permute(f, xs) {\n            return Seq.ofArray(FArray.permute(f, Array.from(xs)));\n        };\n\n        Seq.rangeStep = function rangeStep(first, step, last) {\n            if (step === 0) throw \"Step cannot be 0\";\n            return Seq.unfold(function (x) {\n                return step > 0 && x <= last || step < 0 && x >= last ? [x, x + step] : null;\n            }, first);\n        };\n\n        Seq.rangeChar = function rangeChar(first, last) {\n            return Seq.unfold(function (x) {\n                return x <= last ? [x, String.fromCharCode(x.charCodeAt(0) + 1)] : null;\n            }, first);\n        };\n\n        Seq.range = function range(first, last) {\n            return Seq.rangeStep(first, 1, last);\n        };\n\n        Seq.readOnly = function readOnly(xs) {\n            return Seq.map(function (x) {\n                return x;\n            }, xs);\n        };\n\n        Seq.reduce = function reduce(f, xs) {\n            if (Array.isArray(xs) || ArrayBuffer.isView(xs)) return xs.reduce(f);\n            var iter = xs[Symbol.iterator]();\n            var cur = iter.next();\n            if (cur.done) throw \"Seq was empty\";\n            var acc = cur.value;\n            for (;;) {\n                cur = iter.next();\n                if (cur.done) break;\n                acc = f(acc, cur.value);\n            }\n            return acc;\n        };\n\n        Seq.reduceBack = function reduceBack(f, xs) {\n            var ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n            if (ar.length === 0) throw \"Seq was empty\";\n            var acc = ar[ar.length - 1];\n            for (var i = ar.length - 2; i >= 0; i--) {\n                acc = f(ar[i], acc, i);\n            }return acc;\n        };\n\n        Seq.replicate = function replicate(n, x) {\n            return Seq.initialize(n, function () {\n                return x;\n            });\n        };\n\n        Seq.reverse = function reverse(xs) {\n            var ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\n            return Seq.ofArray(ar.reverse());\n        };\n\n        Seq.scan = function scan(f, seed, xs) {\n            return Seq.delay(function () {\n                var iter = xs[Symbol.iterator]();\n                return Seq.unfold(function (acc) {\n                    if (acc == null) return [seed, seed];\n                    var cur = iter.next();\n                    if (!cur.done) {\n                        acc = f(acc, cur.value);\n                        return [acc, acc];\n                    }\n                    return void 0;\n                }, null);\n            });\n        };\n\n        Seq.scanBack = function scanBack(f, xs, seed) {\n            return Seq.reverse(Seq.scan(function (acc, x) {\n                return f(x, acc);\n            }, seed, Seq.reverse(xs)));\n        };\n\n        Seq.singleton = function singleton(x) {\n            return Seq.unfold(function (x) {\n                return x != null ? [x, null] : null;\n            }, x);\n        };\n\n        Seq.skip = function skip(n, xs) {\n            return _defineProperty({}, Symbol.iterator, function () {\n                var iter = xs[Symbol.iterator]();\n                for (var i = 1; i <= n; i++) {\n                    if (iter.next().done) throw \"Seq has not enough elements\";\n                }return iter;\n            });\n        };\n\n        Seq.skipWhile = function skipWhile(f, xs) {\n            return Seq.delay(function () {\n                var hasPassed = false;\n                return Seq.filter(function (x) {\n                    return hasPassed || (hasPassed = !f(x));\n                }, xs);\n            });\n        };\n\n        Seq.sortWith = function sortWith(f, xs) {\n            var ys = Array.from(xs);\n            return Seq.ofArray(ys.sort(f));\n        };\n\n        Seq.sum = function sum(xs) {\n            return Seq.fold(function (acc, x) {\n                return acc + x;\n            }, 0, xs);\n        };\n\n        Seq.sumBy = function sumBy(f, xs) {\n            return Seq.fold(function (acc, x) {\n                return acc + f(x);\n            }, 0, xs);\n        };\n\n        Seq.tail = function tail(xs) {\n            var iter = xs[Symbol.iterator]();\n            var cur = iter.next();\n            if (cur.done) throw \"Seq was empty\";\n            return _defineProperty({}, Symbol.iterator, function () {\n                return iter;\n            });\n        };\n\n        Seq.take = function take(n, xs) {\n            var truncate = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n            return Seq.delay(function () {\n                var iter = xs[Symbol.iterator]();\n                return Seq.unfold(function (i) {\n                    if (i < n) {\n                        var cur = iter.next();\n                        if (!cur.done) return [cur.value, i + 1];\n                        if (!truncate) throw \"Seq has not enough elements\";\n                    }\n                    return void 0;\n                }, 0);\n            });\n        };\n\n        Seq.truncate = function truncate(n, xs) {\n            return Seq.take(n, xs, true);\n        };\n\n        Seq.takeWhile = function takeWhile(f, xs) {\n            return Seq.delay(function () {\n                var iter = xs[Symbol.iterator]();\n                return Seq.unfold(function (i) {\n                    var cur = iter.next();\n                    if (!cur.done && f(cur.value)) return [cur.value, null];\n                    return void 0;\n                }, 0);\n            });\n        };\n\n        Seq.tryFind = function tryFind(f, xs, defaultValue) {\n            for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n                var cur = iter.next();\n                if (cur.done) return defaultValue === void 0 ? null : defaultValue;\n                if (f(cur.value, i)) return cur.value;\n            }\n        };\n\n        Seq.find = function find(f, xs) {\n            return Seq.__failIfNone(Seq.tryFind(f, xs));\n        };\n\n        Seq.tryFindBack = function tryFindBack(f, xs, defaultValue) {\n            var match = null;\n            for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n                var cur = iter.next();\n                if (cur.done) return match === null ? defaultValue === void 0 ? null : defaultValue : match;\n                if (f(cur.value, i)) match = cur.value;\n            }\n        };\n\n        Seq.findBack = function findBack(f, xs) {\n            return Seq.__failIfNone(Seq.tryFindBack(f, xs));\n        };\n\n        Seq.tryFindIndex = function tryFindIndex(f, xs) {\n            for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n                var cur = iter.next();\n                if (cur.done) return null;\n                if (f(cur.value, i)) return i;\n            }\n        };\n\n        Seq.findIndex = function findIndex(f, xs) {\n            return Seq.__failIfNone(Seq.tryFindIndex(f, xs));\n        };\n\n        Seq.tryFindIndexBack = function tryFindIndexBack(f, xs) {\n            var match = -1;\n            for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n                var cur = iter.next();\n                if (cur.done) return match === -1 ? null : match;\n                if (f(cur.value, i)) match = i;\n            }\n        };\n\n        Seq.findIndexBack = function findIndexBack(f, xs) {\n            return Seq.__failIfNone(Seq.tryFindIndexBack(f, xs));\n        };\n\n        Seq.tryPick = function tryPick(f, xs) {\n            for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n                var cur = iter.next();\n                if (cur.done) break;\n                var y = f(cur.value, i);\n                if (y != null) return y;\n            }\n            return void 0;\n        };\n\n        Seq.pick = function pick(f, xs) {\n            return Seq.__failIfNone(Seq.tryPick(f, xs));\n        };\n\n        Seq.unfold = function unfold(f, acc) {\n            return _defineProperty({}, Symbol.iterator, function () {\n                return {\n                    next: function next() {\n                        var res = f(acc);\n                        if (res != null) {\n                            acc = res[1];\n                            return { done: false, value: res[0] };\n                        }\n                        return { done: true };\n                    }\n                };\n            });\n        };\n\n        Seq.zip = function zip(xs, ys) {\n            return Seq.map2(function (x, y) {\n                return [x, y];\n            }, xs, ys);\n        };\n\n        Seq.zip3 = function zip3(xs, ys, zs) {\n            return Seq.map3(function (x, y, z) {\n                return [x, y, z];\n            }, xs, ys, zs);\n        };\n\n        return Seq;\n    }();\n\n    var SetTree = function () {\n        function SetTree(caseName, fields) {\n            _classCallCheck(this, SetTree);\n\n            this.Case = caseName;\n            this.Fields = fields;\n        }\n\n        SetTree.countAux = function countAux(s, acc) {\n            return s.Case === \"SetOne\" ? acc + 1 : s.Case === \"SetEmpty\" ? acc : SetTree.countAux(s.Fields[1], SetTree.countAux(s.Fields[2], acc + 1));\n        };\n\n        SetTree.count = function count(s) {\n            return SetTree.countAux(s, 0);\n        };\n\n        SetTree.SetOne = function SetOne(n) {\n            return new SetTree(\"SetOne\", [n]);\n        };\n\n        SetTree.SetNode = function SetNode(x, l, r, h) {\n            return new SetTree(\"SetNode\", [x, l, r, h]);\n        };\n\n        SetTree.height = function height(t) {\n            return t.Case === \"SetOne\" ? 1 : t.Case === \"SetNode\" ? t.Fields[3] : 0;\n        };\n\n        SetTree.mk = function mk(l, k, r) {\n            var matchValue = [l, r];\n            var $target1 = function $target1() {\n                var hl = SetTree.height(l);\n                var hr = SetTree.height(r);\n                var m = hl < hr ? hr : hl;\n                return SetTree.SetNode(k, l, r, m + 1);\n            };\n            if (matchValue[0].Case === \"SetEmpty\") {\n                if (matchValue[1].Case === \"SetEmpty\") {\n                    return SetTree.SetOne(k);\n                } else {\n                    return $target1();\n                }\n            } else {\n                return $target1();\n            }\n        };\n\n        SetTree.rebalance = function rebalance(t1, k, t2) {\n            var t1h = SetTree.height(t1);\n            var t2h = SetTree.height(t2);\n            if (t2h > t1h + SetTree.tolerance) {\n                if (t2.Case === \"SetNode\") {\n                    if (SetTree.height(t2.Fields[1]) > t1h + 1) {\n                        if (t2.Fields[1].Case === \"SetNode\") {\n                            return SetTree.mk(SetTree.mk(t1, k, t2.Fields[1].Fields[1]), t2.Fields[1].Fields[0], SetTree.mk(t2.Fields[1].Fields[2], t2.Fields[0], t2.Fields[2]));\n                        } else {\n                            throw \"rebalance\";\n                        }\n                    } else {\n                        return SetTree.mk(SetTree.mk(t1, k, t2.Fields[1]), t2.Fields[0], t2.Fields[2]);\n                    }\n                } else {\n                    throw \"rebalance\";\n                }\n            } else {\n                if (t1h > t2h + SetTree.tolerance) {\n                    if (t1.Case === \"SetNode\") {\n                        if (SetTree.height(t1.Fields[2]) > t2h + 1) {\n                            if (t1.Fields[2].Case === \"SetNode\") {\n                                return SetTree.mk(SetTree.mk(t1.Fields[1], t1.Fields[0], t1.Fields[2].Fields[1]), t1.Fields[2].Fields[0], SetTree.mk(t1.Fields[2].Fields[2], k, t2));\n                            } else {\n                                throw \"rebalance\";\n                            }\n                        } else {\n                            return SetTree.mk(t1.Fields[1], t1.Fields[0], SetTree.mk(t1.Fields[2], k, t2));\n                        }\n                    } else {\n                        throw \"rebalance\";\n                    }\n                } else {\n                    return SetTree.mk(t1, k, t2);\n                }\n            }\n        };\n\n        SetTree.add = function add(comparer, k, t) {\n            return t.Case === \"SetOne\" ? function () {\n                var c = comparer.Compare(k, t.Fields[0]);\n                if (c < 0) {\n                    return SetTree.SetNode(k, new SetTree(\"SetEmpty\", []), t, 2);\n                } else {\n                    if (c === 0) {\n                        return t;\n                    } else {\n                        return SetTree.SetNode(k, t, new SetTree(\"SetEmpty\", []), 2);\n                    }\n                }\n            }() : t.Case === \"SetEmpty\" ? SetTree.SetOne(k) : function () {\n                var c = comparer.Compare(k, t.Fields[0]);\n                if (c < 0) {\n                    return SetTree.rebalance(SetTree.add(comparer, k, t.Fields[1]), t.Fields[0], t.Fields[2]);\n                } else {\n                    if (c === 0) {\n                        return t;\n                    } else {\n                        return SetTree.rebalance(t.Fields[1], t.Fields[0], SetTree.add(comparer, k, t.Fields[2]));\n                    }\n                }\n            }();\n        };\n\n        SetTree.balance = function balance(comparer, t1, k, t2) {\n            var matchValue = [t1, t2];\n            var $target1 = function $target1(t1_1) {\n                return SetTree.add(comparer, k, t1_1);\n            };\n            var $target2 = function $target2(k1, t2_1) {\n                return SetTree.add(comparer, k, SetTree.add(comparer, k1, t2_1));\n            };\n            if (matchValue[0].Case === \"SetOne\") {\n                if (matchValue[1].Case === \"SetEmpty\") {\n                    return $target1(matchValue[0]);\n                } else {\n                    if (matchValue[1].Case === \"SetOne\") {\n                        return $target2(matchValue[0].Fields[0], matchValue[1]);\n                    } else {\n                        return $target2(matchValue[0].Fields[0], matchValue[1]);\n                    }\n                }\n            } else {\n                if (matchValue[0].Case === \"SetNode\") {\n                    if (matchValue[1].Case === \"SetOne\") {\n                        var k2 = matchValue[1].Fields[0];\n                        var t1_1 = matchValue[0];\n                        return SetTree.add(comparer, k, SetTree.add(comparer, k2, t1_1));\n                    } else {\n                        if (matchValue[1].Case === \"SetNode\") {\n                            var h1 = matchValue[0].Fields[3];\n                            var h2 = matchValue[1].Fields[3];\n                            var k1 = matchValue[0].Fields[0];\n                            var k2 = matchValue[1].Fields[0];\n                            var t11 = matchValue[0].Fields[1];\n                            var t12 = matchValue[0].Fields[2];\n                            var t21 = matchValue[1].Fields[1];\n                            var t22 = matchValue[1].Fields[2];\n                            if (h1 + SetTree.tolerance < h2) {\n                                return SetTree.rebalance(SetTree.balance(comparer, t1, k, t21), k2, t22);\n                            } else {\n                                if (h2 + SetTree.tolerance < h1) {\n                                    return SetTree.rebalance(t11, k1, SetTree.balance(comparer, t12, k, t2));\n                                } else {\n                                    return SetTree.mk(t1, k, t2);\n                                }\n                            }\n                        } else {\n                            return $target1(matchValue[0]);\n                        }\n                    }\n                } else {\n                    var t2_1 = matchValue[1];\n                    return SetTree.add(comparer, k, t2_1);\n                }\n            }\n        };\n\n        SetTree.split = function split(comparer, pivot, t) {\n            return t.Case === \"SetOne\" ? function () {\n                var c = comparer.Compare(t.Fields[0], pivot);\n                if (c < 0) {\n                    return [t, false, new SetTree(\"SetEmpty\", [])];\n                } else {\n                    if (c === 0) {\n                        return [new SetTree(\"SetEmpty\", []), true, new SetTree(\"SetEmpty\", [])];\n                    } else {\n                        return [new SetTree(\"SetEmpty\", []), false, t];\n                    }\n                }\n            }() : t.Case === \"SetEmpty\" ? [new SetTree(\"SetEmpty\", []), false, new SetTree(\"SetEmpty\", [])] : function () {\n                var c = comparer.Compare(pivot, t.Fields[0]);\n                if (c < 0) {\n                    var patternInput = SetTree.split(comparer, pivot, t.Fields[1]);\n                    var t11Lo = patternInput[0];\n                    var t11Hi = patternInput[2];\n                    var havePivot = patternInput[1];\n                    return [t11Lo, havePivot, SetTree.balance(comparer, t11Hi, t.Fields[0], t.Fields[2])];\n                } else {\n                    if (c === 0) {\n                        return [t.Fields[1], true, t.Fields[2]];\n                    } else {\n                        var patternInput = SetTree.split(comparer, pivot, t.Fields[2]);\n                        var t12Lo = patternInput[0];\n                        var t12Hi = patternInput[2];\n                        var havePivot = patternInput[1];\n                        return [SetTree.balance(comparer, t.Fields[1], t.Fields[0], t12Lo), havePivot, t12Hi];\n                    }\n                }\n            }();\n        };\n\n        SetTree.spliceOutSuccessor = function spliceOutSuccessor(t) {\n            return t.Case === \"SetOne\" ? [t.Fields[0], new SetTree(\"SetEmpty\", [])] : t.Case === \"SetNode\" ? t.Fields[1].Case === \"SetEmpty\" ? [t.Fields[0], t.Fields[2]] : function () {\n                var patternInput = SetTree.spliceOutSuccessor(t.Fields[1]);\n                var l_ = patternInput[1];\n                var k3 = patternInput[0];\n                return [k3, SetTree.mk(l_, t.Fields[0], t.Fields[2])];\n            }() : function () {\n                throw \"internal error: Map.spliceOutSuccessor\";\n            }();\n        };\n\n        SetTree.remove = function remove(comparer, k, t) {\n            return t.Case === \"SetOne\" ? function () {\n                var c = comparer.Compare(k, t.Fields[0]);\n                if (c === 0) {\n                    return new SetTree(\"SetEmpty\", []);\n                } else {\n                    return t;\n                }\n            }() : t.Case === \"SetNode\" ? function () {\n                var c = comparer.Compare(k, t.Fields[0]);\n                if (c < 0) {\n                    return SetTree.rebalance(SetTree.remove(comparer, k, t.Fields[1]), t.Fields[0], t.Fields[2]);\n                } else {\n                    if (c === 0) {\n                        var matchValue = [t.Fields[1], t.Fields[2]];\n                        if (matchValue[0].Case === \"SetEmpty\") {\n                            return t.Fields[2];\n                        } else {\n                            if (matchValue[1].Case === \"SetEmpty\") {\n                                return t.Fields[1];\n                            } else {\n                                var patternInput = SetTree.spliceOutSuccessor(t.Fields[2]);\n                                var sk = patternInput[0];\n                                var r_ = patternInput[1];\n                                return SetTree.mk(t.Fields[1], sk, r_);\n                            }\n                        }\n                    } else {\n                        return SetTree.rebalance(t.Fields[1], t.Fields[0], SetTree.remove(comparer, k, t.Fields[2]));\n                    }\n                }\n            }() : t;\n        };\n\n        SetTree.mem = function mem(comparer, k, t) {\n            return t.Case === \"SetOne\" ? comparer.Compare(k, t.Fields[0]) === 0 : t.Case === \"SetEmpty\" ? false : function () {\n                var c = comparer.Compare(k, t.Fields[0]);\n                if (c < 0) {\n                    return SetTree.mem(comparer, k, t.Fields[1]);\n                } else {\n                    if (c === 0) {\n                        return true;\n                    } else {\n                        return SetTree.mem(comparer, k, t.Fields[2]);\n                    }\n                }\n            }();\n        };\n\n        SetTree.iter = function iter(f, t) {\n            if (t.Case === \"SetOne\") {\n                f(t.Fields[0]);\n            } else {\n                if (t.Case === \"SetEmpty\") {} else {\n                    SetTree.iter(f, t.Fields[1]);\n                    f(t.Fields[0]);\n                    SetTree.iter(f, t.Fields[2]);\n                }\n            }\n        };\n\n        SetTree.foldBack = function foldBack(f, m, x) {\n            return m.Case === \"SetOne\" ? f(m.Fields[0], x) : m.Case === \"SetEmpty\" ? x : SetTree.foldBack(f, m.Fields[1], f(m.Fields[0], SetTree.foldBack(f, m.Fields[2], x)));\n        };\n\n        SetTree.fold = function fold(f, x, m) {\n            return m.Case === \"SetOne\" ? f(x, m.Fields[0]) : m.Case === \"SetEmpty\" ? x : function () {\n                var x_1 = SetTree.fold(f, x, m.Fields[1]);\n                var x_2 = f(x_1, m.Fields[0]);\n                return SetTree.fold(f, x_2, m.Fields[2]);\n            }();\n        };\n\n        SetTree.forall = function forall(f, m) {\n            return m.Case === \"SetOne\" ? f(m.Fields[0]) : m.Case === \"SetEmpty\" ? true : (f(m.Fields[0]) ? SetTree.forall(f, m.Fields[1]) : false) ? SetTree.forall(f, m.Fields[2]) : false;\n        };\n\n        SetTree.exists = function exists(f, m) {\n            return m.Case === \"SetOne\" ? f(m.Fields[0]) : m.Case === \"SetEmpty\" ? false : (f(m.Fields[0]) ? true : SetTree.exists(f, m.Fields[1])) ? true : SetTree.exists(f, m.Fields[2]);\n        };\n\n        SetTree.isEmpty = function isEmpty(m) {\n            return m.Case === \"SetEmpty\" ? true : false;\n        };\n\n        SetTree.subset = function subset(comparer, a, b) {\n            return SetTree.forall(function (x) {\n                return SetTree.mem(comparer, x, b);\n            }, a);\n        };\n\n        SetTree.psubset = function psubset(comparer, a, b) {\n            return SetTree.forall(function (x) {\n                return SetTree.mem(comparer, x, b);\n            }, a) ? SetTree.exists(function (x) {\n                return !SetTree.mem(comparer, x, a);\n            }, b) : false;\n        };\n\n        SetTree.filterAux = function filterAux(comparer, f, s, acc) {\n            return s.Case === \"SetOne\" ? f(s.Fields[0]) ? SetTree.add(comparer, s.Fields[0], acc) : acc : s.Case === \"SetEmpty\" ? acc : function () {\n                var acc_1 = f(s.Fields[0]) ? SetTree.add(comparer, s.Fields[0], acc) : acc;\n                return SetTree.filterAux(comparer, f, s.Fields[1], SetTree.filterAux(comparer, f, s.Fields[2], acc_1));\n            }();\n        };\n\n        SetTree.filter = function filter(comparer, f, s) {\n            return SetTree.filterAux(comparer, f, s, new SetTree(\"SetEmpty\", []));\n        };\n\n        SetTree.diffAux = function diffAux(comparer, m, acc) {\n            return m.Case === \"SetOne\" ? SetTree.remove(comparer, m.Fields[0], acc) : m.Case === \"SetEmpty\" ? acc : SetTree.diffAux(comparer, m.Fields[1], SetTree.diffAux(comparer, m.Fields[2], SetTree.remove(comparer, m.Fields[0], acc)));\n        };\n\n        SetTree.diff = function diff(comparer, a, b) {\n            return SetTree.diffAux(comparer, b, a);\n        };\n\n        SetTree.union = function union(comparer, t1, t2) {\n            var matchValue = [t1, t2];\n            var $target2 = function $target2(t) {\n                return t;\n            };\n            var $target3 = function $target3(k1, t2_1) {\n                return SetTree.add(comparer, k1, t2_1);\n            };\n            if (matchValue[0].Case === \"SetEmpty\") {\n                var t = matchValue[1];\n                return t;\n            } else {\n                if (matchValue[0].Case === \"SetOne\") {\n                    if (matchValue[1].Case === \"SetEmpty\") {\n                        return $target2(matchValue[0]);\n                    } else {\n                        if (matchValue[1].Case === \"SetOne\") {\n                            return $target3(matchValue[0].Fields[0], matchValue[1]);\n                        } else {\n                            return $target3(matchValue[0].Fields[0], matchValue[1]);\n                        }\n                    }\n                } else {\n                    if (matchValue[1].Case === \"SetEmpty\") {\n                        return $target2(matchValue[0]);\n                    } else {\n                        if (matchValue[1].Case === \"SetOne\") {\n                            var k2 = matchValue[1].Fields[0];\n                            var t1_1 = matchValue[0];\n                            return SetTree.add(comparer, k2, t1_1);\n                        } else {\n                            var h1 = matchValue[0].Fields[3];\n                            var h2 = matchValue[1].Fields[3];\n                            var k1 = matchValue[0].Fields[0];\n                            var k2 = matchValue[1].Fields[0];\n                            var t11 = matchValue[0].Fields[1];\n                            var t12 = matchValue[0].Fields[2];\n                            var t21 = matchValue[1].Fields[1];\n                            var t22 = matchValue[1].Fields[2];\n                            if (h1 > h2) {\n                                var patternInput = SetTree.split(comparer, k1, t2);\n                                var lo = patternInput[0];\n                                var hi = patternInput[2];\n                                return SetTree.balance(comparer, SetTree.union(comparer, t11, lo), k1, SetTree.union(comparer, t12, hi));\n                            } else {\n                                var patternInput = SetTree.split(comparer, k2, t1);\n                                var lo = patternInput[0];\n                                var hi = patternInput[2];\n                                return SetTree.balance(comparer, SetTree.union(comparer, t21, lo), k2, SetTree.union(comparer, t22, hi));\n                            }\n                        }\n                    }\n                }\n            }\n        };\n\n        SetTree.intersectionAux = function intersectionAux(comparer, b, m, acc) {\n            return m.Case === \"SetOne\" ? SetTree.mem(comparer, m.Fields[0], b) ? SetTree.add(comparer, m.Fields[0], acc) : acc : m.Case === \"SetEmpty\" ? acc : function () {\n                var acc_1 = SetTree.intersectionAux(comparer, b, m.Fields[2], acc);\n                var acc_2 = SetTree.mem(comparer, m.Fields[0], b) ? SetTree.add(comparer, m.Fields[0], acc_1) : acc_1;\n                return SetTree.intersectionAux(comparer, b, m.Fields[1], acc_2);\n            }();\n        };\n\n        SetTree.intersection = function intersection(comparer, a, b) {\n            return SetTree.intersectionAux(comparer, b, a, new SetTree(\"SetEmpty\", []));\n        };\n\n        SetTree.partition1 = function partition1(comparer, f, k, acc1, acc2) {\n            return f(k) ? [SetTree.add(comparer, k, acc1), acc2] : [acc1, SetTree.add(comparer, k, acc2)];\n        };\n\n        SetTree.partitionAux = function partitionAux(comparer, f, s, acc_0, acc_1) {\n            var acc = [acc_0, acc_1];\n            if (s.Case === \"SetOne\") {\n                var acc1 = acc[0];\n                var acc2 = acc[1];\n                return SetTree.partition1(comparer, f, s.Fields[0], acc1, acc2);\n            } else {\n                if (s.Case === \"SetEmpty\") {\n                    return acc;\n                } else {\n                    var acc_2 = function () {\n                        var arg30_ = acc[0];\n                        var arg31_ = acc[1];\n                        return SetTree.partitionAux(comparer, f, s.Fields[2], arg30_, arg31_);\n                    }();\n                    var acc_3 = function () {\n                        var acc1 = acc_2[0];\n                        var acc2 = acc_2[1];\n                        return SetTree.partition1(comparer, f, s.Fields[0], acc1, acc2);\n                    }();\n                    var arg30_ = acc_3[0];\n                    var arg31_ = acc_3[1];\n                    return SetTree.partitionAux(comparer, f, s.Fields[1], arg30_, arg31_);\n                }\n            }\n        };\n\n        SetTree.partition = function partition(comparer, f, s) {\n            var seed = [new SetTree(\"SetEmpty\", []), new SetTree(\"SetEmpty\", [])];\n            var arg30_ = seed[0];\n            var arg31_ = seed[1];\n            return SetTree.partitionAux(comparer, f, s, arg30_, arg31_);\n        };\n\n        SetTree.minimumElementAux = function minimumElementAux(s, n) {\n            return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? n : SetTree.minimumElementAux(s.Fields[1], s.Fields[0]);\n        };\n\n        SetTree.minimumElementOpt = function minimumElementOpt(s) {\n            return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? null : SetTree.minimumElementAux(s.Fields[1], s.Fields[0]);\n        };\n\n        SetTree.maximumElementAux = function maximumElementAux(s, n) {\n            return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? n : SetTree.maximumElementAux(s.Fields[2], s.Fields[0]);\n        };\n\n        SetTree.maximumElementOpt = function maximumElementOpt(s) {\n            return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? null : SetTree.maximumElementAux(s.Fields[2], s.Fields[0]);\n        };\n\n        SetTree.minimumElement = function minimumElement(s) {\n            var matchValue = SetTree.minimumElementOpt(s);\n            if (matchValue == null) {\n                throw \"Set contains no elements\";\n            } else {\n                return matchValue;\n            }\n        };\n\n        SetTree.maximumElement = function maximumElement(s) {\n            var matchValue = SetTree.maximumElementOpt(s);\n            if (matchValue == null) {\n                throw \"Set contains no elements\";\n            } else {\n                return matchValue;\n            }\n        };\n\n        SetTree.collapseLHS = function collapseLHS(stack) {\n            return stack.tail != null ? stack.head.Case === \"SetOne\" ? stack : stack.head.Case === \"SetNode\" ? SetTree.collapseLHS(List.ofArray([stack.head.Fields[1], SetTree.SetOne(stack.head.Fields[0]), stack.head.Fields[2]], stack.tail)) : SetTree.collapseLHS(stack.tail) : new List();\n        };\n\n        SetTree.mkIterator = function mkIterator(s) {\n            return { stack: SetTree.collapseLHS(new List(s, new List())), started: false };\n        };\n\n        SetTree.moveNext = function moveNext(i) {\n            function current(i) {\n                if (i.stack.tail == null) {\n                    return null;\n                } else if (i.stack.head.Case === \"SetOne\") {\n                    return i.stack.head.Fields[0];\n                }\n                throw \"Please report error: Set iterator, unexpected stack for current\";\n            }\n            if (i.started) {\n                if (i.stack.tail == null) {\n                    return { done: true };\n                } else {\n                    if (i.stack.head.Case === \"SetOne\") {\n                        i.stack = SetTree.collapseLHS(i.stack.tail);\n                        return {\n                            done: i.stack.tail == null,\n                            value: current(i)\n                        };\n                    } else {\n                        throw \"Please report error: Set iterator, unexpected stack for moveNext\";\n                    }\n                }\n            } else {\n                i.started = true;\n                return {\n                    done: i.stack.tail == null,\n                    value: current(i)\n                };\n            }\n            ;\n        };\n\n        SetTree.compareStacks = function compareStacks(comparer, l1, l2) {\n            var $target8 = function $target8(n1k, t1) {\n                return SetTree.compareStacks(comparer, List.ofArray([new SetTree(\"SetEmpty\", []), SetTree.SetOne(n1k)], t1), l2);\n            };\n            var $target9 = function $target9(n1k, n1l, n1r, t1) {\n                return SetTree.compareStacks(comparer, List.ofArray([n1l, SetTree.SetNode(n1k, new SetTree(\"SetEmpty\", []), n1r, 0)], t1), l2);\n            };\n            var $target11 = function $target11(n2k, n2l, n2r, t2) {\n                return SetTree.compareStacks(comparer, l1, List.ofArray([n2l, SetTree.SetNode(n2k, new SetTree(\"SetEmpty\", []), n2r, 0)], t2));\n            };\n            if (l1.tail != null) {\n                if (l2.tail != null) {\n                    if (l2.head.Case === \"SetOne\") {\n                        if (l1.head.Case === \"SetOne\") {\n                            var n1k = l1.head.Fields[0],\n                                n2k = l2.head.Fields[0],\n                                t1 = l1.tail,\n                                t2 = l2.tail,\n                                c = comparer.Compare(n1k, n2k);\n                            if (c !== 0) {\n                                return c;\n                            } else {\n                                return SetTree.compareStacks(comparer, t1, t2);\n                            }\n                        } else {\n                            if (l1.head.Case === \"SetNode\") {\n                                if (l1.head.Fields[1].Case === \"SetEmpty\") {\n                                    var emp = l1.head.Fields[1],\n                                        _n1k = l1.head.Fields[0],\n                                        n1r = l1.head.Fields[2],\n                                        _n2k = l2.head.Fields[0],\n                                        _t = l1.tail,\n                                        _t2 = l2.tail,\n                                        _c = comparer.Compare(_n1k, _n2k);\n                                    if (_c !== 0) {\n                                        return _c;\n                                    } else {\n                                        return SetTree.compareStacks(comparer, List.ofArray([n1r], _t), List.ofArray([emp], _t2));\n                                    }\n                                } else {\n                                    return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\n                                }\n                            } else {\n                                var _n2k2 = l2.head.Fields[0],\n                                    _t3 = l2.tail;\n                                return SetTree.compareStacks(comparer, l1, List.ofArray([new SetTree(\"SetEmpty\", []), SetTree.SetOne(_n2k2)], _t3));\n                            }\n                        }\n                    } else {\n                        if (l2.head.Case === \"SetNode\") {\n                            if (l2.head.Fields[1].Case === \"SetEmpty\") {\n                                if (l1.head.Case === \"SetOne\") {\n                                    var _n1k2 = l1.head.Fields[0],\n                                        _n2k3 = l2.head.Fields[0],\n                                        n2r = l2.head.Fields[2],\n                                        _t4 = l1.tail,\n                                        _t5 = l2.tail,\n                                        _c2 = comparer.Compare(_n1k2, _n2k3);\n                                    if (_c2 !== 0) {\n                                        return _c2;\n                                    } else {\n                                        return SetTree.compareStacks(comparer, List.ofArray([new SetTree(\"SetEmpty\", [])], _t4), List.ofArray([n2r], _t5));\n                                    }\n                                } else {\n                                    if (l1.head.Case === \"SetNode\") {\n                                        if (l1.head.Fields[1].Case === \"SetEmpty\") {\n                                            var _n1k3 = l1.head.Fields[0],\n                                                _n1r = l1.head.Fields[2],\n                                                _n2k4 = l2.head.Fields[0],\n                                                _n2r = l2.head.Fields[2],\n                                                _t6 = l1.tail,\n                                                _t7 = l2.tail,\n                                                _c3 = comparer.Compare(_n1k3, _n2k4);\n                                            if (_c3 !== 0) {\n                                                return _c3;\n                                            } else {\n                                                return SetTree.compareStacks(comparer, List.ofArray([_n1r], _t6), List.ofArray([_n2r], _t7));\n                                            }\n                                        } else {\n                                            return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\n                                        }\n                                    } else {\n                                        return $target11(l2.head.Fields[0], l2.head.Fields[1], l2.head.Fields[2], l2.tail);\n                                    }\n                                }\n                            } else {\n                                if (l1.head.Case === \"SetOne\") {\n                                    return $target8(l1.head.Fields[0], l1.tail);\n                                } else {\n                                    if (l1.head.Case === \"SetNode\") {\n                                        return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\n                                    } else {\n                                        return $target11(l2.head.Fields[0], l2.head.Fields[1], l2.head.Fields[2], l2.tail);\n                                    }\n                                }\n                            }\n                        } else {\n                            if (l1.head.Case === \"SetOne\") {\n                                return $target8(l1.head.Fields[0], l1.tail);\n                            } else {\n                                if (l1.head.Case === \"SetNode\") {\n                                    return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\n                                } else {\n                                    return SetTree.compareStacks(comparer, l1.tail, l2.tail);\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    return 1;\n                }\n            } else {\n                if (l2.tail != null) {\n                    return -1;\n                } else {\n                    return 0;\n                }\n            }\n        };\n\n        SetTree.compare = function compare(comparer, s1, s2) {\n            if (s1.Case === \"SetEmpty\") {\n                if (s2.Case === \"SetEmpty\") {\n                    return 0;\n                } else {\n                    return -1;\n                }\n            } else {\n                if (s2.Case === \"SetEmpty\") {\n                    return 1;\n                } else {\n                    return SetTree.compareStacks(comparer, List.ofArray([s1]), List.ofArray([s2]));\n                }\n            }\n        };\n\n        SetTree.mkFromEnumerator = function mkFromEnumerator(comparer, acc, e) {\n            var cur = e.next();\n            while (!cur.done) {\n                acc = SetTree.add(comparer, cur.value, acc);\n                cur = e.next();\n            }\n            return acc;\n        };\n\n        SetTree.ofSeq = function ofSeq(comparer, c) {\n            var ie = c[Symbol.iterator]();\n            return SetTree.mkFromEnumerator(comparer, new SetTree(\"SetEmpty\", []), ie);\n        };\n\n        return SetTree;\n    }();\n\n    SetTree.tolerance = 2;\n\n    var FSet = function () {\n        /** Do not call, use Set.create instead. */\n        function FSet() {\n            _classCallCheck(this, FSet);\n        }\n\n        FSet.from = function from(comparer, tree) {\n            var s = new FSet();\n            s.tree = tree;\n            s.comparer = comparer || new GenericComparer();\n            return s;\n        };\n\n        FSet.create = function create(ie, comparer) {\n            comparer = comparer || new GenericComparer();\n            return FSet.from(comparer, ie ? SetTree.ofSeq(comparer, ie) : new SetTree(\"SetEmpty\", []));\n        };\n\n        FSet.prototype.ToString = function ToString() {\n            return \"set [\" + Array.from(this).map(Util.toString).join(\"; \") + \"]\";\n        };\n\n        FSet.prototype.Equals = function Equals(s2) {\n            return this.CompareTo(s2) === 0;\n        };\n\n        FSet.prototype.CompareTo = function CompareTo(s2) {\n            return SetTree.compare(this.comparer, this.tree, s2.tree);\n        };\n\n        FSet.prototype[Symbol.iterator] = function () {\n            var i = SetTree.mkIterator(this.tree);\n            return {\n                next: function next() {\n                    return SetTree.moveNext(i);\n                }\n            };\n        };\n\n        FSet.prototype.values = function values() {\n            return this[Symbol.iterator]();\n        };\n\n        FSet.prototype.has = function has(v) {\n            return SetTree.mem(this.comparer, v, this.tree);\n        };\n\n        FSet.prototype.add = function add(v) {\n            throw \"not supported\";\n        };\n\n        FSet.prototype.delete = function _delete(v) {\n            throw \"not supported\";\n        };\n\n        FSet.prototype.clear = function clear() {\n            throw \"not supported\";\n        };\n\n        FSet.isEmpty = function isEmpty(s) {\n            return SetTree.isEmpty(s.tree);\n        };\n\n        FSet.add = function add(item, s) {\n            return FSet.from(s.comparer, SetTree.add(s.comparer, item, s.tree));\n        };\n\n        FSet.addInPlace = function addInPlace(item, s) {\n            return s.has(item) ? false : (s.add(item), true);\n        };\n\n        FSet.remove = function remove(item, s) {\n            return FSet.from(s.comparer, SetTree.remove(s.comparer, item, s.tree));\n        };\n\n        FSet.union = function union(set1, set2) {\n            return set2.tree.Case === \"SetEmpty\" ? set1 : set1.tree.Case === \"SetEmpty\" ? set2 : FSet.from(set1.comparer, SetTree.union(set1.comparer, set1.tree, set2.tree));\n        };\n\n        FSet.unionInPlace = function unionInPlace(set1, set2) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = set2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var x = _step.value;\n\n                    set1.add(x);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        };\n\n        FSet.unionMany = function unionMany(sets) {\n            // Pass args as FSet.union(s, acc) instead of FSet.union(acc, s)\n            // to discard the comparer of the first empty set \n            return Seq.fold(function (acc, s) {\n                return FSet.union(s, acc);\n            }, FSet.create(), sets);\n        };\n\n        FSet.difference = function difference(set1, set2) {\n            return set1.tree.Case === \"SetEmpty\" ? set1 : set2.tree.Case === \"SetEmpty\" ? set1 : FSet.from(set1.comparer, SetTree.diff(set1.comparer, set1.tree, set2.tree));\n        };\n\n        FSet.differenceInPlace = function differenceInPlace(set1, set2) {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = set2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var x = _step2.value;\n\n                    set1.delete(x);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        };\n\n        FSet.intersect = function intersect(set1, set2) {\n            return set2.tree.Case === \"SetEmpty\" ? set2 : set1.tree.Case === \"SetEmpty\" ? set1 : FSet.from(set1.comparer, SetTree.intersection(set1.comparer, set1.tree, set2.tree));\n        };\n\n        FSet.intersectInPlace = function intersectInPlace(set1, set2) {\n            var set2_ = set2 instanceof Set ? set2 : new Set(set2);\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = set1[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var x = _step3.value;\n\n                    if (!set2_.has(x)) {\n                        set1.delete(x);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n        };\n\n        FSet.intersectMany = function intersectMany(sets) {\n            return Seq.reduce(function (s1, s2) {\n                return FSet.intersect(s1, s2);\n            }, sets);\n        };\n\n        FSet.isProperSubsetOf = function isProperSubsetOf(set1, set2) {\n            if (set1 instanceof FSet && set2 instanceof FSet) {\n                return SetTree.psubset(set1.comparer, set1.tree, set2.tree);\n            } else {\n                set2 = set2 instanceof Set ? set2 : new Set(set2);\n                return Seq.forAll(function (x) {\n                    return set2.has(x);\n                }, set1) && Seq.exists(function (x) {\n                    return !set1.has(x);\n                }, set2);\n            }\n        };\n\n        FSet.isSubsetOf = function isSubsetOf(set1, set2) {\n            if (set1 instanceof FSet && set2 instanceof FSet) {\n                return SetTree.subset(set1.comparer, set1.tree, set2.tree);\n            } else {\n                set2 = set2 instanceof Set ? set2 : new Set(set2);\n                return Seq.forAll(function (x) {\n                    return set2.has(x);\n                }, set1);\n            }\n        };\n\n        FSet.isProperSupersetOf = function isProperSupersetOf(set1, set2) {\n            if (set1 instanceof FSet && set2 instanceof FSet) {\n                return SetTree.psubset(set1.comparer, set2.tree, set1.tree);\n            } else {\n                return FSet.isProperSubset(set2 instanceof Set ? set2 : new Set(set2), set1);\n            }\n        };\n\n        FSet.isSupersetOf = function isSupersetOf(set1, set2) {\n            if (set1 instanceof FSet && set2 instanceof FSet) {\n                return SetTree.subset(set1.comparer, set2.tree, set1.tree);\n            } else {\n                return FSet.isSubset(set2 instanceof Set ? set2 : new Set(set2), set1);\n            }\n        };\n\n        FSet.copyTo = function copyTo(xs, arr, arrayIndex, count) {\n            if (!Array.isArray(arr) && !ArrayBuffer.isView(arr)) throw \"Array is invalid\";\n            count = count || arr.length;\n            var i = arrayIndex || 0;\n            var iter = xs[Symbol.iterator]();\n            while (count--) {\n                var el = iter.next();\n                if (el.done) break;\n                arr[i++] = el.value;\n            }\n        };\n\n        FSet.partition = function partition(f, s) {\n            if (s.tree.Case === \"SetEmpty\") {\n                return [s, s];\n            } else {\n                var tuple = SetTree.partition(s.comparer, f, s.tree);\n                return [FSet.from(s.comparer, tuple[0]), FSet.from(s.comparer, tuple[1])];\n            }\n        };\n\n        FSet.filter = function filter(f, s) {\n            if (s.tree.Case === \"SetEmpty\") {\n                return s;\n            } else {\n                return FSet.from(s.comparer, SetTree.filter(s.comparer, f, s.tree));\n            }\n        };\n\n        FSet.map = function map(f, s) {\n            var comparer = new GenericComparer();\n            return FSet.from(comparer, SetTree.fold(function (acc, k) {\n                return SetTree.add(comparer, f(k), acc);\n            }, new SetTree(\"SetEmpty\", []), s.tree));\n        };\n\n        FSet.exists = function exists(f, s) {\n            return SetTree.exists(f, s.tree);\n        };\n\n        FSet.forAll = function forAll(f, s) {\n            return SetTree.forall(f, s.tree);\n        };\n\n        FSet.fold = function fold(f, seed, s) {\n            return SetTree.fold(f, seed, s.tree);\n        };\n\n        FSet.foldBack = function foldBack(f, s, seed) {\n            return SetTree.foldBack(f, s.tree, seed);\n        };\n\n        FSet.iterate = function iterate(f, s) {\n            SetTree.iter(f, s.tree);\n        };\n\n        FSet.minimumElement = function minimumElement(s) {\n            return SetTree.minimumElement(s.tree);\n        };\n\n        FSet.maximumElement = function maximumElement(s) {\n            return SetTree.maximumElement(s.tree);\n        };\n\n        _createClass(FSet, [{\n            key: \"size\",\n            get: function get() {\n                return SetTree.count(this.tree);\n            }\n        }]);\n\n        return FSet;\n    }();\n\n    FSet.op_Addition = FSet.union;\n    FSet.op_Subtraction = FSet.difference;\n    FSet.isProperSubset = FSet.isProperSubsetOf;\n    FSet.isSubset = FSet.isSubsetOf;\n    FSet.isProperSuperset = FSet.isProperSupersetOf;\n    FSet.isSuperset = FSet.isSupersetOf;\n    FSet.minElement = FSet.minimumElement;\n    FSet.maxElement = FSet.maximumElement;\n    Util.setInterfaces(FSet.prototype, [\"System.IEquatable\", \"System.IComparable\"], \"Microsoft.FSharp.Collections.FSharpSet\");\n    exports.Set = FSet;\n\n    var MapTree = function () {\n        function MapTree(caseName, fields) {\n            _classCallCheck(this, MapTree);\n\n            this.Case = caseName;\n            this.Fields = fields;\n        }\n\n        MapTree.sizeAux = function sizeAux(acc, m) {\n            return m.Case === \"MapOne\" ? acc + 1 : m.Case === \"MapNode\" ? MapTree.sizeAux(MapTree.sizeAux(acc + 1, m.Fields[2]), m.Fields[3]) : acc;\n        };\n\n        MapTree.size = function size(x) {\n            return MapTree.sizeAux(0, x);\n        };\n\n        MapTree.empty = function empty() {\n            return new MapTree(\"MapEmpty\", []);\n        };\n\n        MapTree.height = function height(_arg1) {\n            return _arg1.Case === \"MapOne\" ? 1 : _arg1.Case === \"MapNode\" ? _arg1.Fields[4] : 0;\n        };\n\n        MapTree.isEmpty = function isEmpty(m) {\n            return m.Case === \"MapEmpty\" ? true : false;\n        };\n\n        MapTree.mk = function mk(l, k, v, r) {\n            var matchValue = [l, r];\n            var $target1 = function $target1() {\n                var hl = MapTree.height(l);\n                var hr = MapTree.height(r);\n                var m = hl < hr ? hr : hl;\n                return new MapTree(\"MapNode\", [k, v, l, r, m + 1]);\n            };\n            if (matchValue[0].Case === \"MapEmpty\") {\n                if (matchValue[1].Case === \"MapEmpty\") {\n                    return new MapTree(\"MapOne\", [k, v]);\n                } else {\n                    return $target1();\n                }\n            } else {\n                return $target1();\n            }\n        };\n\n        MapTree.rebalance = function rebalance(t1, k, v, t2) {\n            var t1h = MapTree.height(t1);\n            var t2h = MapTree.height(t2);\n            if (t2h > t1h + 2) {\n                if (t2.Case === \"MapNode\") {\n                    if (MapTree.height(t2.Fields[2]) > t1h + 1) {\n                        if (t2.Fields[2].Case === \"MapNode\") {\n                            return MapTree.mk(MapTree.mk(t1, k, v, t2.Fields[2].Fields[2]), t2.Fields[2].Fields[0], t2.Fields[2].Fields[1], MapTree.mk(t2.Fields[2].Fields[3], t2.Fields[0], t2.Fields[1], t2.Fields[3]));\n                        } else {\n                            throw \"rebalance\";\n                        }\n                    } else {\n                        return MapTree.mk(MapTree.mk(t1, k, v, t2.Fields[2]), t2.Fields[0], t2.Fields[1], t2.Fields[3]);\n                    }\n                } else {\n                    throw \"rebalance\";\n                }\n            } else {\n                if (t1h > t2h + 2) {\n                    if (t1.Case === \"MapNode\") {\n                        if (MapTree.height(t1.Fields[3]) > t2h + 1) {\n                            if (t1.Fields[3].Case === \"MapNode\") {\n                                return MapTree.mk(MapTree.mk(t1.Fields[2], t1.Fields[0], t1.Fields[1], t1.Fields[3].Fields[2]), t1.Fields[3].Fields[0], t1.Fields[3].Fields[1], MapTree.mk(t1.Fields[3].Fields[3], k, v, t2));\n                            } else {\n                                throw \"rebalance\";\n                            }\n                        } else {\n                            return MapTree.mk(t1.Fields[2], t1.Fields[0], t1.Fields[1], MapTree.mk(t1.Fields[3], k, v, t2));\n                        }\n                    } else {\n                        throw \"rebalance\";\n                    }\n                } else {\n                    return MapTree.mk(t1, k, v, t2);\n                }\n            }\n        };\n\n        MapTree.add = function add(comparer, k, v, m) {\n            if (m.Case === \"MapOne\") {\n                var c = comparer.Compare(k, m.Fields[0]);\n                if (c < 0) {\n                    return new MapTree(\"MapNode\", [k, v, new MapTree(\"MapEmpty\", []), m, 2]);\n                } else if (c === 0) {\n                    return new MapTree(\"MapOne\", [k, v]);\n                }\n                return new MapTree(\"MapNode\", [k, v, m, new MapTree(\"MapEmpty\", []), 2]);\n            } else if (m.Case === \"MapNode\") {\n                var c = comparer.Compare(k, m.Fields[0]);\n                if (c < 0) {\n                    return MapTree.rebalance(MapTree.add(comparer, k, v, m.Fields[2]), m.Fields[0], m.Fields[1], m.Fields[3]);\n                } else if (c === 0) {\n                    return new MapTree(\"MapNode\", [k, v, m.Fields[2], m.Fields[3], m.Fields[4]]);\n                }\n                return MapTree.rebalance(m.Fields[2], m.Fields[0], m.Fields[1], MapTree.add(comparer, k, v, m.Fields[3]));\n            }\n            return new MapTree(\"MapOne\", [k, v]);\n        };\n\n        MapTree.find = function find(comparer, k, m) {\n            var res = MapTree.tryFind(comparer, k, m);\n            if (res != null) return res;\n            throw \"key not found\";\n        };\n\n        MapTree.tryFind = function tryFind(comparer, k, m) {\n            if (m.Case === \"MapOne\") {\n                var c = comparer.Compare(k, m.Fields[0]);\n                return c === 0 ? m.Fields[1] : null;\n            } else if (m.Case === \"MapNode\") {\n                var c = comparer.Compare(k, m.Fields[0]);\n                if (c < 0) {\n                    return MapTree.tryFind(comparer, k, m.Fields[2]);\n                } else {\n                    if (c === 0) {\n                        return m.Fields[1];\n                    } else {\n                        return MapTree.tryFind(comparer, k, m.Fields[3]);\n                    }\n                }\n            }\n            return null;\n        };\n\n        MapTree.partition1 = function partition1(comparer, f, k, v, acc1, acc2) {\n            return f(k, v) ? [MapTree.add(comparer, k, v, acc1), acc2] : [acc1, MapTree.add(comparer, k, v, acc2)];\n        };\n\n        MapTree.partitionAux = function partitionAux(comparer, f, s, acc_0, acc_1) {\n            var acc = [acc_0, acc_1];\n            if (s.Case === \"MapOne\") {\n                return MapTree.partition1(comparer, f, s.Fields[0], s.Fields[1], acc[0], acc[1]);\n            } else if (s.Case === \"MapNode\") {\n                var acc_2 = MapTree.partitionAux(comparer, f, s.Fields[3], acc[0], acc[1]);\n                var acc_3 = MapTree.partition1(comparer, f, s.Fields[0], s.Fields[1], acc_2[0], acc_2[1]);\n                return MapTree.partitionAux(comparer, f, s.Fields[2], acc_3[0], acc_3[1]);\n            }\n            return acc;\n        };\n\n        MapTree.partition = function partition(comparer, f, s) {\n            return MapTree.partitionAux(comparer, f, s, MapTree.empty(), MapTree.empty());\n        };\n\n        MapTree.filter1 = function filter1(comparer, f, k, v, acc) {\n            return f(k, v) ? MapTree.add(comparer, k, v, acc) : acc;\n        };\n\n        MapTree.filterAux = function filterAux(comparer, f, s, acc) {\n            return s.Case === \"MapOne\" ? MapTree.filter1(comparer, f, s.Fields[0], s.Fields[1], acc) : s.Case === \"MapNode\" ? function () {\n                var acc_1 = MapTree.filterAux(comparer, f, s.Fields[2], acc);\n                var acc_2 = MapTree.filter1(comparer, f, s.Fields[0], s.Fields[1], acc_1);\n                return MapTree.filterAux(comparer, f, s.Fields[3], acc_2);\n            }() : acc;\n        };\n\n        MapTree.filter = function filter(comparer, f, s) {\n            return MapTree.filterAux(comparer, f, s, MapTree.empty());\n        };\n\n        MapTree.spliceOutSuccessor = function spliceOutSuccessor(m) {\n            if (m.Case === \"MapOne\") {\n                return [m.Fields[0], m.Fields[1], new MapTree(\"MapEmpty\", [])];\n            } else if (m.Case === \"MapNode\") {\n                if (m.Fields[2].Case === \"MapEmpty\") {\n                    return [m.Fields[0], m.Fields[1], m.Fields[3]];\n                } else {\n                    var kvl = MapTree.spliceOutSuccessor(m.Fields[2]);\n                    return [kvl[0], kvl[1], MapTree.mk(kvl[2], m.Fields[0], m.Fields[1], m.Fields[3])];\n                }\n            }\n            throw \"internal error: Map.spliceOutSuccessor\";\n        };\n\n        MapTree.remove = function remove(comparer, k, m) {\n            if (m.Case === \"MapOne\") {\n                var c = comparer.Compare(k, m.Fields[0]);\n                if (c === 0) {\n                    return new MapTree(\"MapEmpty\", []);\n                } else {\n                    return m;\n                }\n            } else if (m.Case === \"MapNode\") {\n                var c = comparer.Compare(k, m.Fields[0]);\n                if (c < 0) {\n                    return MapTree.rebalance(MapTree.remove(comparer, k, m.Fields[2]), m.Fields[0], m.Fields[1], m.Fields[3]);\n                } else {\n                    if (c === 0) {\n                        var matchValue = [m.Fields[2], m.Fields[3]];\n                        if (matchValue[0].Case === \"MapEmpty\") {\n                            return m.Fields[3];\n                        } else {\n                            if (matchValue[1].Case === \"MapEmpty\") {\n                                return m.Fields[2];\n                            } else {\n                                var patternInput = MapTree.spliceOutSuccessor(m.Fields[3]);\n                                var sv = patternInput[1];\n                                var sk = patternInput[0];\n                                var r_ = patternInput[2];\n                                return MapTree.mk(m.Fields[2], sk, sv, r_);\n                            }\n                        }\n                    } else {\n                        return MapTree.rebalance(m.Fields[2], m.Fields[0], m.Fields[1], MapTree.remove(comparer, k, m.Fields[3]));\n                    }\n                }\n            } else {\n                return MapTree.empty();\n            }\n        };\n\n        MapTree.mem = function mem(comparer, k, m) {\n            return m.Case === \"MapOne\" ? comparer.Compare(k, m.Fields[0]) === 0 : m.Case === \"MapNode\" ? function () {\n                var c = comparer.Compare(k, m.Fields[0]);\n                if (c < 0) {\n                    return MapTree.mem(comparer, k, m.Fields[2]);\n                } else {\n                    if (c === 0) {\n                        return true;\n                    } else {\n                        return MapTree.mem(comparer, k, m.Fields[3]);\n                    }\n                }\n            }() : false;\n        };\n\n        MapTree.iter = function iter(f, m) {\n            if (m.Case === \"MapOne\") {\n                f(m.Fields[0], m.Fields[1]);\n            } else if (m.Case === \"MapNode\") {\n                MapTree.iter(f, m.Fields[2]);\n                f(m.Fields[0], m.Fields[1]);\n                MapTree.iter(f, m.Fields[3]);\n            }\n        };\n\n        MapTree.tryPick = function tryPick(f, m) {\n            return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? function () {\n                var matchValue = MapTree.tryPick(f, m.Fields[2]);\n                if (matchValue == null) {\n                    var matchValue_1 = f(m.Fields[0], m.Fields[1]);\n                    if (matchValue_1 == null) {\n                        return MapTree.tryPick(f, m.Fields[3]);\n                    } else {\n                        var res = matchValue_1;\n                        return res;\n                    }\n                } else {\n                    var res = matchValue;\n                    return res;\n                }\n            }() : null;\n        };\n\n        MapTree.exists = function exists(f, m) {\n            return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? (MapTree.exists(f, m.Fields[2]) ? true : f(m.Fields[0], m.Fields[1])) ? true : MapTree.exists(f, m.Fields[3]) : false;\n        };\n\n        MapTree.forall = function forall(f, m) {\n            return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? (MapTree.forall(f, m.Fields[2]) ? f(m.Fields[0], m.Fields[1]) : false) ? MapTree.forall(f, m.Fields[3]) : false : true;\n        };\n\n        MapTree.mapi = function mapi(f, m) {\n            return m.Case === \"MapOne\" ? new MapTree(\"MapOne\", [m.Fields[0], f(m.Fields[0], m.Fields[1])]) : m.Case === \"MapNode\" ? function () {\n                var l2 = MapTree.mapi(f, m.Fields[2]);\n                var v2 = f(m.Fields[0], m.Fields[1]);\n                var r2 = MapTree.mapi(f, m.Fields[3]);\n                return new MapTree(\"MapNode\", [m.Fields[0], v2, l2, r2, m.Fields[4]]);\n            }() : MapTree.empty();\n        };\n\n        MapTree.foldBack = function foldBack(f, m, x) {\n            return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1], x) : m.Case === \"MapNode\" ? function () {\n                var x_1 = MapTree.foldBack(f, m.Fields[3], x);\n                var x_2 = f(m.Fields[0], m.Fields[1], x_1);\n                return MapTree.foldBack(f, m.Fields[2], x_2);\n            }() : x;\n        };\n\n        MapTree.fold = function fold(f, x, m) {\n            return m.Case === \"MapOne\" ? f(x, m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? function () {\n                var x_1 = MapTree.fold(f, x, m.Fields[2]);\n                var x_2 = f(x_1, m.Fields[0], m.Fields[1]);\n                return MapTree.fold(f, x_2, m.Fields[3]);\n            }() : x;\n        };\n\n        MapTree.mkFromEnumerator = function mkFromEnumerator(comparer, acc, e) {\n            var cur = e.next();\n            while (!cur.done) {\n                acc = MapTree.add(comparer, cur.value[0], cur.value[1], acc);\n                cur = e.next();\n            }\n            return acc;\n        };\n\n        MapTree.ofSeq = function ofSeq(comparer, c) {\n            var ie = c[Symbol.iterator]();\n            return MapTree.mkFromEnumerator(comparer, MapTree.empty(), ie);\n        };\n\n        MapTree.collapseLHS = function collapseLHS(stack) {\n            if (stack.tail != null) {\n                if (stack.head.Case === \"MapOne\") {\n                    return stack;\n                } else if (stack.head.Case === \"MapNode\") {\n                    return MapTree.collapseLHS(List.ofArray([stack.head.Fields[2], new MapTree(\"MapOne\", [stack.head.Fields[0], stack.head.Fields[1]]), stack.head.Fields[3]], stack.tail));\n                } else {\n                    return MapTree.collapseLHS(stack.tail);\n                }\n            } else {\n                return new List();\n            }\n        };\n\n        MapTree.mkIterator = function mkIterator(s) {\n            return { stack: MapTree.collapseLHS(new List(s, new List())), started: false };\n        };\n\n        MapTree.moveNext = function moveNext(i) {\n            function current(i) {\n                if (i.stack.tail == null) {\n                    return null;\n                } else if (i.stack.head.Case === \"MapOne\") {\n                    return [i.stack.head.Fields[0], i.stack.head.Fields[1]];\n                }\n                throw \"Please report error: Map iterator, unexpected stack for current\";\n            }\n            if (i.started) {\n                if (i.stack.tail == null) {\n                    return { done: true };\n                } else {\n                    if (i.stack.head.Case === \"MapOne\") {\n                        i.stack = MapTree.collapseLHS(i.stack.tail);\n                        return {\n                            done: i.stack.tail == null,\n                            value: current(i)\n                        };\n                    } else {\n                        throw \"Please report error: Map iterator, unexpected stack for moveNext\";\n                    }\n                }\n            } else {\n                i.started = true;\n                return {\n                    done: i.stack.tail == null,\n                    value: current(i)\n                };\n            }\n            ;\n        };\n\n        return MapTree;\n    }();\n\n    var FMap = function () {\n        /** Do not call, use Map.create instead. */\n        function FMap() {\n            _classCallCheck(this, FMap);\n        }\n\n        FMap.from = function from(comparer, tree) {\n            var map = new FMap();\n            map.tree = tree;\n            map.comparer = comparer || new GenericComparer();\n            return map;\n        };\n\n        FMap.create = function create(ie, comparer) {\n            comparer = comparer || new GenericComparer();\n            return FMap.from(comparer, ie ? MapTree.ofSeq(comparer, ie) : MapTree.empty());\n        };\n\n        FMap.prototype.ToString = function ToString() {\n            return \"map [\" + Array.from(this).map(Util.toString).join(\"; \") + \"]\";\n        };\n\n        FMap.prototype.Equals = function Equals(m2) {\n            return this.CompareTo(m2) === 0;\n        };\n\n        FMap.prototype.CompareTo = function CompareTo(m2) {\n            var _this4 = this;\n\n            return Seq.compareWith(function (kvp1, kvp2) {\n                var c = _this4.comparer.Compare(kvp1[0], kvp2[0]);\n                return c !== 0 ? c : Util.compare(kvp1[1], kvp2[1]);\n            }, this, m2);\n        };\n\n        FMap.prototype[Symbol.iterator] = function () {\n            var i = MapTree.mkIterator(this.tree);\n            return {\n                next: function next() {\n                    return MapTree.moveNext(i);\n                }\n            };\n        };\n\n        FMap.prototype.entries = function entries() {\n            return this[Symbol.iterator]();\n        };\n\n        FMap.prototype.keys = function keys() {\n            return Seq.map(function (kv) {\n                return kv[0];\n            }, this);\n        };\n\n        FMap.prototype.values = function values() {\n            return Seq.map(function (kv) {\n                return kv[1];\n            }, this);\n        };\n\n        FMap.prototype.get = function get(k) {\n            return MapTree.find(this.comparer, k, this.tree);\n        };\n\n        FMap.prototype.has = function has(k) {\n            return MapTree.mem(this.comparer, k, this.tree);\n        };\n\n        FMap.prototype.set = function set(k, v) {\n            throw \"not supported\";\n        };\n\n        FMap.prototype.delete = function _delete(k) {\n            throw \"not supported\";\n        };\n\n        FMap.prototype.clear = function clear() {\n            throw \"not supported\";\n        };\n\n        FMap.add = function add(k, v, map) {\n            return FMap.from(map.comparer, MapTree.add(map.comparer, k, v, map.tree));\n        };\n\n        FMap.remove = function remove(item, map) {\n            return FMap.from(map.comparer, MapTree.remove(map.comparer, item, map.tree));\n        };\n\n        FMap.containsValue = function containsValue(v, map) {\n            return Seq.fold(function (acc, k) {\n                return acc || Util.equals(map.get(k), v);\n            }, false, map.keys());\n        };\n\n        FMap.exists = function exists(f, map) {\n            return MapTree.exists(f, map.tree);\n        };\n\n        FMap.find = function find(k, map) {\n            return MapTree.find(map.comparer, k, map.tree);\n        };\n\n        FMap.tryFind = function tryFind(k, map) {\n            return MapTree.tryFind(map.comparer, k, map.tree);\n        };\n\n        FMap.filter = function filter(f, map) {\n            return FMap.from(map.comparer, MapTree.filter(map.comparer, f, map.tree));\n        };\n\n        FMap.fold = function fold(f, seed, map) {\n            return MapTree.fold(f, seed, map.tree);\n        };\n\n        FMap.foldBack = function foldBack(f, map, seed) {\n            return MapTree.foldBack(f, map.tree, seed);\n        };\n\n        FMap.forAll = function forAll(f, map) {\n            return MapTree.forall(f, map.tree);\n        };\n\n        FMap.isEmpty = function isEmpty(map) {\n            return MapTree.isEmpty(map.tree);\n        };\n\n        FMap.iterate = function iterate(f, map) {\n            MapTree.iter(f, map.tree);\n        };\n\n        FMap.map = function map(f, _map) {\n            return FMap.from(_map.comparer, MapTree.mapi(f, _map.tree));\n        };\n\n        FMap.partition = function partition(f, map) {\n            var rs = MapTree.partition(map.comparer, f, map.tree);\n            return [FMap.from(map.comparer, rs[0]), FMap.from(map.comparer, rs[1])];\n        };\n\n        FMap.findKey = function findKey(f, map) {\n            return Seq.pick(function (kv) {\n                return f(kv[0], kv[1]) ? kv[0] : null;\n            }, map);\n        };\n\n        FMap.tryFindKey = function tryFindKey(f, map) {\n            return Seq.tryPick(function (kv) {\n                return f(kv[0], kv[1]) ? kv[0] : null;\n            }, map);\n        };\n\n        FMap.pick = function pick(f, map) {\n            var res = FMap.tryPick(f, map);\n            if (res != null) return res;\n            throw \"key not found\";\n        };\n\n        FMap.tryPick = function tryPick(f, map) {\n            return MapTree.tryPick(f, map.tree);\n        };\n\n        _createClass(FMap, [{\n            key: \"size\",\n            get: function get() {\n                return MapTree.size(this.tree);\n            }\n        }]);\n\n        return FMap;\n    }();\n\n    Util.setInterfaces(FMap.prototype, [\"System.IEquatable\", \"System.IComparable\"], \"Microsoft.FSharp.Collections.FSharpMap\");\n    exports.Map = FMap;\n    var Nothing = exports.Nothing = void 0;\n    var maxTrampolineCallCount = 2000;\n\n    var Trampoline = exports.Trampoline = function () {\n        function Trampoline() {\n            _classCallCheck(this, Trampoline);\n\n            this.callCount = 0;\n        }\n\n        Trampoline.prototype.incrementAndCheck = function incrementAndCheck() {\n            return this.callCount++ > maxTrampolineCallCount;\n        };\n\n        Trampoline.prototype.hijack = function hijack(f) {\n            this.callCount = 0;\n            setTimeout(f, 0);\n        };\n\n        return Trampoline;\n    }();\n\n    var AsyncImpl = {\n        protectedCont: function protectedCont(f) {\n            return function (ctx) {\n                if (ctx.cancelToken.isCancelled) ctx.onCancel(\"cancelled\");else if (ctx.trampoline.incrementAndCheck()) ctx.trampoline.hijack(function () {\n                    try {\n                        f(ctx);\n                    } catch (err) {\n                        ctx.onError(err);\n                    }\n                });else try {\n                    f(ctx);\n                } catch (err) {\n                    ctx.onError(err);\n                }\n            };\n        },\n        bind: function bind(computation, binder) {\n            return AsyncImpl.protectedCont(function (ctx) {\n                computation({\n                    onSuccess: function onSuccess(x) {\n                        return binder(x)(ctx);\n                    },\n                    onError: ctx.onError,\n                    onCancel: ctx.onCancel,\n                    cancelToken: ctx.cancelToken,\n                    trampoline: ctx.trampoline\n                });\n            });\n        },\n        return: function _return(value) {\n            return AsyncImpl.protectedCont(function (ctx) {\n                return ctx.onSuccess(value);\n            });\n        }\n    };\n\n    var AsyncBuilder = exports.AsyncBuilder = function () {\n        function AsyncBuilder() {\n            _classCallCheck(this, AsyncBuilder);\n        }\n\n        AsyncBuilder.prototype.Bind = function Bind(computation, binder) {\n            return AsyncImpl.bind(computation, binder);\n        };\n\n        AsyncBuilder.prototype.Combine = function Combine(computation1, computation2) {\n            return this.Bind(computation1, function () {\n                return computation2;\n            });\n        };\n\n        AsyncBuilder.prototype.Delay = function Delay(generator) {\n            return AsyncImpl.protectedCont(function (ctx) {\n                return generator()(ctx);\n            });\n        };\n\n        AsyncBuilder.prototype.For = function For(sequence, body) {\n            var iter = sequence[Symbol.iterator]();\n            var cur = iter.next();\n            return this.While(function () {\n                return !cur.done;\n            }, this.Delay(function () {\n                var res = body(cur.value);\n                cur = iter.next();\n                return res;\n            }));\n        };\n\n        AsyncBuilder.prototype.Return = function Return(value) {\n            return AsyncImpl.return(value);\n        };\n\n        AsyncBuilder.prototype.ReturnFrom = function ReturnFrom(computation) {\n            return computation;\n        };\n\n        AsyncBuilder.prototype.TryFinally = function TryFinally(computation, compensation) {\n            return AsyncImpl.protectedCont(function (ctx) {\n                computation({\n                    onSuccess: function onSuccess(x) {\n                        compensation();\n                        ctx.onSuccess(x);\n                    },\n                    onError: function onError(x) {\n                        compensation();\n                        ctx.onError(x);\n                    },\n                    onCancel: function onCancel(x) {\n                        compensation();\n                        ctx.onCancel(x);\n                    },\n                    cancelToken: ctx.cancelToken,\n                    trampoline: ctx.trampoline\n                });\n            });\n        };\n\n        AsyncBuilder.prototype.TryWith = function TryWith(computation, catchHandler) {\n            return AsyncImpl.protectedCont(function (ctx) {\n                computation({\n                    onSuccess: ctx.onSuccess,\n                    onCancel: ctx.onCancel,\n                    cancelToken: ctx.cancelToken,\n                    trampoline: ctx.trampoline,\n                    onError: function onError(ex) {\n                        try {\n                            catchHandler(ex)(ctx);\n                        } catch (ex2) {\n                            ctx.onError(ex2);\n                        }\n                    }\n                });\n            });\n        };\n\n        AsyncBuilder.prototype.Using = function Using(resource, binder) {\n            return this.TryFinally(binder(resource), function () {\n                return resource.Dispose();\n            });\n        };\n\n        AsyncBuilder.prototype.While = function While(guard, computation) {\n            var _this5 = this;\n\n            if (guard()) return this.Bind(computation, function () {\n                return _this5.While(guard, computation);\n            });else return this.Return(Nothing);\n        };\n\n        AsyncBuilder.prototype.Zero = function Zero() {\n            return AsyncImpl.protectedCont(function (ctx) {\n                return ctx.onSuccess(Nothing);\n            });\n        };\n\n        return AsyncBuilder;\n    }();\n\n    AsyncBuilder.singleton = new AsyncBuilder();\n\n    var Async = exports.Async = function () {\n        function Async() {\n            _classCallCheck(this, Async);\n        }\n\n        Async.awaitPromise = function awaitPromise(p) {\n            return Async.fromContinuations(function (conts) {\n                return p.then(conts[0]).catch(function (err) {\n                    return (err == \"cancelled\" ? conts[2] : conts[1])(err);\n                });\n            });\n        };\n\n        Async.catch = function _catch(work) {\n            return AsyncImpl.protectedCont(function (ctx) {\n                work({\n                    onSuccess: function onSuccess(x) {\n                        return ctx.onSuccess(Choice.Choice1Of2(x));\n                    },\n                    onError: function onError(ex) {\n                        return ctx.onSuccess(Choice.Choice2Of2(ex));\n                    },\n                    onCancel: ctx.onCancel,\n                    cancelToken: ctx.cancelToken,\n                    trampoline: ctx.trampoline\n                });\n            });\n        };\n\n        Async.fromContinuations = function fromContinuations(f) {\n            return AsyncImpl.protectedCont(function (ctx) {\n                return f([ctx.onSuccess, ctx.onError, ctx.onCancel]);\n            });\n        };\n\n        Async.ignore = function ignore(computation) {\n            return AsyncImpl.bind(computation, function (x) {\n                return AsyncImpl.return(Nothing);\n            });\n        };\n\n        Async.parallel = function parallel(computations) {\n            return Async.awaitPromise(Promise.all(Seq.map(function (w) {\n                return Async.startAsPromise(w);\n            }, computations)));\n        };\n\n        Async.sleep = function sleep(millisecondsDueTime) {\n            return AsyncImpl.protectedCont(function (ctx) {\n                setTimeout(function () {\n                    return ctx.cancelToken.isCancelled ? ctx.onCancel(\"cancelled\") : ctx.onSuccess(Nothing);\n                }, millisecondsDueTime);\n            });\n        };\n\n        Async.start = function start(computation, cancellationToken) {\n            return Async.startWithContinuations(computation, cancellationToken);\n        };\n\n        Async.emptyContinuation = function emptyContinuation(x) {\n            // NOP\n        };\n\n        Async.startWithContinuations = function startWithContinuations(computation, continuation, exceptionContinuation, cancellationContinuation, cancelToken) {\n            if (typeof continuation !== \"function\") {\n                cancelToken = continuation;\n                continuation = null;\n            }\n            var trampoline = new Trampoline();\n            computation({\n                onSuccess: continuation ? continuation : Async.emptyContinuation,\n                onError: exceptionContinuation ? exceptionContinuation : Async.emptyContinuation,\n                onCancel: cancellationContinuation ? cancellationContinuation : Async.emptyContinuation,\n                cancelToken: cancelToken ? cancelToken : Async.defaultCancellationToken,\n                trampoline: trampoline\n            });\n        };\n\n        Async.startAsPromise = function startAsPromise(computation, cancellationToken) {\n            return new Promise(function (resolve, reject) {\n                return Async.startWithContinuations(computation, resolve, reject, reject, cancellationToken ? cancellationToken : Async.defaultCancellationToken);\n            });\n        };\n\n        _createClass(Async, null, [{\n            key: \"cancellationToken\",\n            get: function get() {\n                return AsyncImpl.protectedCont(function (ctx) {\n                    return ctx.onSuccess(ctx.cancelToken);\n                });\n            }\n        }]);\n\n        return Async;\n    }();\n\n    Async.defaultCancellationToken = {\n        isCancelled: false\n    };\n    Async.startImmediate = Async.start;\n\n    var QueueCell = function QueueCell(message) {\n        _classCallCheck(this, QueueCell);\n\n        this.value = message;\n    };\n\n    var MailboxQueue = function () {\n        function MailboxQueue() {\n            _classCallCheck(this, MailboxQueue);\n        }\n\n        MailboxQueue.prototype.add = function add(message) {\n            var itCell = new QueueCell(message);\n            if (this.firstAndLast) {\n                this.firstAndLast[1].next = itCell;\n                this.firstAndLast = [this.firstAndLast[0], itCell];\n            } else this.firstAndLast = [itCell, itCell];\n        };\n\n        MailboxQueue.prototype.tryGet = function tryGet() {\n            if (this.firstAndLast) {\n                var value = this.firstAndLast[0].value;\n                if (this.firstAndLast[0].next) this.firstAndLast = [this.firstAndLast[0].next, this.firstAndLast[1]];else delete this.firstAndLast;\n                return value;\n            }\n            return void 0;\n        };\n\n        return MailboxQueue;\n    }();\n\n    var MailboxProcessor = exports.MailboxProcessor = function () {\n        function MailboxProcessor(body, cancellationToken) {\n            _classCallCheck(this, MailboxProcessor);\n\n            this.body = body;\n            this.cancellationToken = cancellationToken || Async.defaultCancellationToken;\n            this.messages = new MailboxQueue();\n        }\n\n        MailboxProcessor.start = function start(body, cancellationToken) {\n            var mbox = new MailboxProcessor(body, cancellationToken);\n            mbox.start();\n            return mbox;\n        };\n\n        MailboxProcessor.prototype.__processEvents = function __processEvents() {\n            if (this.continuation) {\n                var value = this.messages.tryGet();\n                if (value) {\n                    var cont = this.continuation;\n                    delete this.continuation;\n                    cont(value);\n                }\n            }\n        };\n\n        MailboxProcessor.prototype.start = function start() {\n            Async.startImmediate(this.body(this), this.cancellationToken);\n        };\n\n        MailboxProcessor.prototype.receive = function receive() {\n            var _this6 = this;\n\n            return Async.fromContinuations(function (conts) {\n                if (_this6.continuation) throw \"Receive can only be called once!\";\n                _this6.continuation = conts[0];\n                _this6.__processEvents();\n            });\n        };\n\n        MailboxProcessor.prototype.post = function post(message) {\n            this.messages.add(message);\n            this.__processEvents();\n        };\n\n        MailboxProcessor.prototype.postAndAsyncReply = function postAndAsyncReply(buildMessage) {\n            var result = void 0;\n            var continuation = void 0;\n            function checkCompletion() {\n                if (result && continuation) continuation(result);\n            }\n            var reply = {\n                reply: function reply(res) {\n                    result = res;\n                    checkCompletion();\n                }\n            };\n            this.messages.add(buildMessage(reply));\n            this.__processEvents();\n            return Async.fromContinuations(function (conts) {\n                continuation = conts[0];\n                checkCompletion();\n            });\n        };\n\n        return MailboxProcessor;\n    }();\n\n    var Observer = function Observer(onNext, onError, onCompleted) {\n        _classCallCheck(this, Observer);\n\n        this.OnNext = onNext;\n        this.OnError = onError || function (e) {};\n        this.OnCompleted = onCompleted || function () {};\n    };\n\n    Util.setInterfaces(Observer.prototype, [\"System.IObserver\"]);\n\n    var Observable = function Observable(subscribe) {\n        _classCallCheck(this, Observable);\n\n        this.Subscribe = subscribe;\n    };\n\n    Util.setInterfaces(Observable.prototype, [\"System.IObservable\"]);\n\n    var FObservable = function () {\n        function FObservable() {\n            _classCallCheck(this, FObservable);\n        }\n\n        FObservable.__protect = function __protect(f, succeed, fail) {\n            try {\n                return succeed(f());\n            } catch (e) {\n                fail(e);\n            }\n        };\n\n        FObservable.add = function add(callback, source) {\n            source.Subscribe(new Observer(callback));\n        };\n\n        FObservable.choose = function choose(chooser, source) {\n            return new Observable(function (observer) {\n                return source.Subscribe(new Observer(function (t) {\n                    return FObservable.__protect(function () {\n                        return chooser(t);\n                    }, function (u) {\n                        if (u != null) observer.OnNext(u);\n                    }, observer.OnError);\n                }, observer.OnError, observer.OnCompleted));\n            });\n        };\n\n        FObservable.filter = function filter(predicate, source) {\n            return FObservable.choose(function (x) {\n                return predicate(x) ? x : null;\n            }, source);\n        };\n\n        FObservable.map = function map(mapping, source) {\n            return new Observable(function (observer) {\n                return source.Subscribe(new Observer(function (t) {\n                    FObservable.__protect(function () {\n                        return mapping(t);\n                    }, observer.OnNext, observer.OnError);\n                }, observer.OnError, observer.OnCompleted));\n            });\n        };\n\n        FObservable.merge = function merge(source1, source2) {\n            return new Observable(function (observer) {\n                var stopped = false,\n                    completed1 = false,\n                    completed2 = false;\n                var h1 = source1.Subscribe(new Observer(function (v) {\n                    if (!stopped) observer.OnNext(v);\n                }, function (e) {\n                    if (!stopped) {\n                        stopped = true;\n                        observer.OnError(e);\n                    }\n                }, function () {\n                    if (!stopped) {\n                        completed1 = true;\n                        if (completed2) {\n                            stopped = true;\n                            observer.OnCompleted();\n                        }\n                    }\n                }));\n                var h2 = source2.Subscribe(new Observer(function (v) {\n                    if (!stopped) {\n                        observer.OnNext(v);\n                    }\n                }, function (e) {\n                    if (!stopped) {\n                        stopped = true;\n                        observer.OnError(e);\n                    }\n                }, function () {\n                    if (!stopped) {\n                        completed2 = true;\n                        if (completed1) {\n                            stopped = true;\n                            observer.OnCompleted();\n                        }\n                    }\n                }));\n                return Util.createDisposable(function () {\n                    h1.Dispose();\n                    h2.Dispose();\n                });\n            });\n        };\n\n        FObservable.pairwise = function pairwise(source) {\n            return new Observable(function (observer) {\n                var last = null;\n                return source.Subscribe(new Observer(function (next) {\n                    if (last != null) observer.OnNext([last, next]);\n                    last = next;\n                }, observer.OnError, observer.OnCompleted));\n            });\n        };\n\n        FObservable.partition = function partition(predicate, source) {\n            return Tuple(FObservable.filter(predicate, source), FObservable.filter(function (x) {\n                return !predicate(x);\n            }, source));\n        };\n\n        FObservable.scan = function scan(collector, state, source) {\n            return new Observable(function (observer) {\n                return source.Subscribe(new Observer(function (t) {\n                    FObservable.__protect(function () {\n                        return collector(state, t);\n                    }, function (u) {\n                        state = u;observer.OnNext(u);\n                    }, observer.OnError);\n                }, observer.OnError, observer.OnCompleted));\n            });\n        };\n\n        FObservable.split = function split(splitter, source) {\n            return Tuple(FObservable.choose(function (v) {\n                return splitter(v).valueIfChoice1;\n            }, source), FObservable.choose(function (v) {\n                return splitter(v).valueIfChoice2;\n            }, source));\n        };\n\n        FObservable.subscribe = function subscribe(callback, source) {\n            return source.Subscribe(new Observer(callback));\n        };\n\n        return FObservable;\n    }();\n\n    exports.Observable = FObservable;\n\n    var Event = exports.Event = function () {\n        function Event(_subscriber, delegates) {\n            _classCallCheck(this, Event);\n\n            this._subscriber = _subscriber;\n            this.delegates = delegates || new Array();\n        }\n\n        Event.prototype.Add = function Add(f) {\n            this._addHandler(f);\n        };\n        // IEvent<T> methods\n\n\n        Event.prototype.Trigger = function Trigger(value) {\n            Seq.iterate(function (f) {\n                return f(value);\n            }, this.delegates);\n        };\n        // IDelegateEvent<T> methods\n\n\n        Event.prototype._addHandler = function _addHandler(f) {\n            this.delegates.push(f);\n        };\n\n        Event.prototype._removeHandler = function _removeHandler(f) {\n            var index = this.delegates.findIndex(function (el) {\n                return \"\" + el == \"\" + f;\n            }); // Special dedication to Chet Husk.\n            if (index > -1) this.delegates.splice(index, 1);\n        };\n\n        Event.prototype.AddHandler = function AddHandler(handler) {\n            this._addHandler(function (x) {\n                return handler(undefined, x);\n            });\n        };\n\n        Event.prototype.RemoveHandler = function RemoveHandler(handler) {\n            this._removeHandler(function (x) {\n                return handler(undefined, x);\n            });\n        };\n        // IObservable<T> methods\n\n\n        Event.prototype._subscribeFromObserver = function _subscribeFromObserver(observer) {\n            var _this7 = this;\n\n            if (this._subscriber) return this._subscriber(observer);\n            var callback = observer.OnNext;\n            this._addHandler(callback);\n            return Util.createDisposable(function () {\n                return _this7._removeHandler(callback);\n            });\n        };\n\n        Event.prototype._subscribeFromCallback = function _subscribeFromCallback(callback) {\n            var _this8 = this;\n\n            this._addHandler(callback);\n            return Util.createDisposable(function () {\n                return _this8._removeHandler(callback);\n            });\n        };\n\n        Event.prototype.Subscribe = function Subscribe(arg) {\n            return typeof arg == \"function\" ? this._subscribeFromCallback(arg) : this._subscribeFromObserver(arg);\n        };\n\n        Event.add = function add(callback, sourceEvent) {\n            sourceEvent.Subscribe(new Observer(callback));\n        };\n\n        Event.choose = function choose(chooser, sourceEvent) {\n            var source = sourceEvent;\n            return new Event(function (observer) {\n                return source.Subscribe(new Observer(function (t) {\n                    return FObservable.__protect(function () {\n                        return chooser(t);\n                    }, function (u) {\n                        if (u != null) observer.OnNext(u);\n                    }, observer.OnError);\n                }, observer.OnError, observer.OnCompleted));\n            }, source.delegates);\n        };\n\n        Event.filter = function filter(predicate, sourceEvent) {\n            return Event.choose(function (x) {\n                return predicate(x) ? x : null;\n            }, sourceEvent);\n        };\n\n        Event.map = function map(mapping, sourceEvent) {\n            var source = sourceEvent;\n            return new Event(function (observer) {\n                return source.Subscribe(new Observer(function (t) {\n                    return FObservable.__protect(function () {\n                        return mapping(t);\n                    }, observer.OnNext, observer.OnError);\n                }, observer.OnError, observer.OnCompleted));\n            }, source.delegates);\n        };\n\n        Event.merge = function merge(event1, event2) {\n            var source1 = event1;\n            var source2 = event2;\n            return new Event(function (observer) {\n                var stopped = false,\n                    completed1 = false,\n                    completed2 = false;\n                var h1 = source1.Subscribe(new Observer(function (v) {\n                    if (!stopped) observer.OnNext(v);\n                }, function (e) {\n                    if (!stopped) {\n                        stopped = true;\n                        observer.OnError(e);\n                    }\n                }, function () {\n                    if (!stopped) {\n                        completed1 = true;\n                        if (completed2) {\n                            stopped = true;\n                            observer.OnCompleted();\n                        }\n                    }\n                }));\n                var h2 = source2.Subscribe(new Observer(function (v) {\n                    if (!stopped) observer.OnNext(v);\n                }, function (e) {\n                    if (!stopped) {\n                        stopped = true;\n                        observer.OnError(e);\n                    }\n                }, function () {\n                    if (!stopped) {\n                        completed2 = true;\n                        if (completed1) {\n                            stopped = true;\n                            observer.OnCompleted();\n                        }\n                    }\n                }));\n                return Util.createDisposable(function () {\n                    h1.Dispose();\n                    h2.Dispose();\n                });\n            }, source1.delegates.concat(source2.delegates));\n        };\n\n        Event.pairwise = function pairwise(sourceEvent) {\n            var source = sourceEvent;\n            return new Event(function (observer) {\n                var last = null;\n                return source.Subscribe(new Observer(function (next) {\n                    if (last != null) observer.OnNext([last, next]);\n                    last = next;\n                }, observer.OnError, observer.OnCompleted));\n            }, source.delegates);\n        };\n\n        Event.partition = function partition(predicate, sourceEvent) {\n            return Tuple(Event.filter(predicate, sourceEvent), Event.filter(function (x) {\n                return !predicate(x);\n            }, sourceEvent));\n        };\n\n        Event.scan = function scan(collector, state, sourceEvent) {\n            var source = sourceEvent;\n            return new Event(function (observer) {\n                return source.Subscribe(new Observer(function (t) {\n                    FObservable.__protect(function () {\n                        return collector(state, t);\n                    }, function (u) {\n                        state = u;observer.OnNext(u);\n                    }, observer.OnError);\n                }, observer.OnError, observer.OnCompleted));\n            }, source.delegates);\n        };\n\n        Event.split = function split(splitter, sourceEvent) {\n            return Tuple(Event.choose(function (v) {\n                return splitter(v).valueIfChoice1;\n            }, sourceEvent), Event.choose(function (v) {\n                return splitter(v).valueIfChoice2;\n            }, sourceEvent));\n        };\n\n        _createClass(Event, [{\n            key: \"Publish\",\n            get: function get() {\n                return this;\n            }\n        }]);\n\n        return Event;\n    }();\n\n    var Lazy = exports.Lazy = function () {\n        function Lazy(factory) {\n            _classCallCheck(this, Lazy);\n\n            this.factory = factory;\n            this.isValueCreated = false;\n        }\n\n        Lazy.createFromValue = function createFromValue(v) {\n            return new Lazy(function () {\n                return v;\n            });\n        };\n\n        _createClass(Lazy, [{\n            key: \"value\",\n            get: function get() {\n                if (!this.isValueCreated) {\n                    this.createdValue = this.factory();\n                    this.isValueCreated = true;\n                }\n                return this.createdValue;\n            }\n        }]);\n\n        return Lazy;\n    }();\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fable-core/fable-core.js\n ** module id = 4\n ** module chunks = 0 1\n **/","﻿namespace Pricer.Fabled\r\n\r\nopen System\r\nopen Pricer.Core\r\n\r\nmodule SimpleMath = \r\n    let signOf(x:double) = \r\n        if x < 0.0 then -1.0 else 1.0\r\n\r\n    let cdf(x:double) = \r\n        let a1 = 0.254829592\r\n        let a2 = -0.284496736\r\n        let a3 = 1.421413741\r\n        let a4 = -1.453152027\r\n        let a5 = 1.061405429\r\n        let p = 0.3275911\r\n        \r\n        let absX = abs x\r\n\r\n        \r\n        let t = 1.0 / (1.0 + p*absX);\r\n        let y = 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-absX*absX);\r\n \r\n        let result = (signOf x)*y\r\n        result\r\n\r\ntype SimpleMathProvider() =\r\n\r\n    interface IMathProvider with\r\n        member this.cdf x =  SimpleMath.cdf x\r\n    \n\n\n/** WEBPACK FOOTER **\n ** ./SimpleMath.fs\n **/","﻿namespace Pricer.Fabled\r\n\r\nopen Pricer.Core\r\n\r\ntype StockViewModel(s:StockInfo) = \n    let mutable rate = s.Rate\n    let mutable volatility = s.Volatility\n    let mutable currentPrice = s.CurrentPrice\n\n    member __.buildStock = {\n        Rate = rate\n        Volatility = volatility\n        CurrentPrice = currentPrice\n    }\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ShareViewModels.fs\n **/","﻿namespace Pricer.Core\r\n\r\nopen System\r\n\r\n[<CLIMutable>]\r\ntype StockInfo =\r\n    {\r\n        Rate:float\r\n        Volatility: float\r\n        CurrentPrice: float\r\n    }\r\n\n\n\n/** WEBPACK FOOTER **\n ** ../Pricer.Core/StocksModel.fs\n **/","﻿namespace Pricer.Core\r\n\r\nopen System\r\n\r\nmodule StrategiesExamples = \r\n\r\n    let testStrikes stock =\r\n        floor(stock.CurrentPrice*1.1),floor(stock.CurrentPrice*1.4)\r\n\r\n    let buildOptionLeg direction strike expiry kind = \r\n        {\r\n            Definition = Option {\r\n                Direction = direction\r\n                Strike = strike\r\n                Expiry = expiry\r\n                Kind = kind\r\n                Style = European\r\n                PurchaseDate = DateTime.Now\r\n            }\r\n            Pricing = None\r\n        }\r\n\r\n    let expiry = DateTime.Now.AddDays(60.0)\r\n    let strangle stock = \r\n        let strike1, strike2 = testStrikes stock\r\n        {\r\n            Name = \"Long Strangle\"\r\n            Legs = [ \r\n                    buildOptionLeg 1.0 strike1 expiry Call\r\n                    buildOptionLeg 1.0 strike2 expiry Put\r\n            ]\r\n            Stock = stock\r\n        }\r\n\r\n    let straddle stock = \r\n        let strike,_ = testStrikes stock\r\n        {\r\n            Name = \"Straddle\"\r\n            Legs = [ \r\n                    buildOptionLeg 1.0 strike expiry Call\r\n                    buildOptionLeg 1.0 strike expiry Put\r\n            ]\r\n            Stock = stock\r\n        }\r\n\r\n    let butterfly stock = \r\n        {\r\n            Name = \"Butterfly\"\r\n            Legs = [ \r\n                    buildOptionLeg 1.0 (stock.CurrentPrice*1.05) expiry Call\r\n                    buildOptionLeg -1.0 (stock.CurrentPrice*1.1) expiry Call\r\n                    buildOptionLeg -1.0 (stock.CurrentPrice*1.1) expiry Call\r\n                    buildOptionLeg 1.0 (stock.CurrentPrice*1.15) expiry Call\r\n            ]\r\n            Stock = stock\r\n        }\r\n\r\n    let riskReversal stock = \r\n        {\r\n            Name = \"Risk Reversal\"\r\n            Legs = [ \r\n                    //out of the money call\r\n                    buildOptionLeg 1.0 (stock.CurrentPrice*1.1) expiry Call\r\n                    //out of the money put\r\n                    buildOptionLeg -1.0 (stock.CurrentPrice*0.9) expiry Put\r\n            ]\r\n            Stock = stock\r\n        }\r\n\r\n    let collar stock = {\r\n            Name = \"Collar\"\r\n            Legs = [ \r\n                    //sell 1 out of money call\r\n                    buildOptionLeg -1.0 (stock.CurrentPrice*1.2) expiry Call\r\n                    //buy 1 out of money put\r\n                    buildOptionLeg 1.0 (stock.CurrentPrice*0.8) expiry Put\r\n                    //long some shares\r\n                    {\r\n                        Definition = Cash { \r\n                            Direction = 1.0\r\n                            Price = stock.CurrentPrice\r\n                        }\r\n                        Pricing = None\r\n                    }\r\n            ]\r\n            Stock = stock\r\n        }\r\n\r\n    let coveredCall stock = \r\n        {\r\n            Name = \"Covered Call\"\r\n            Legs = [ \r\n                    //sell 1 out of money call\r\n                    buildOptionLeg -1.0 (stock.CurrentPrice*1.2) expiry Call\r\n                    //long some shares\r\n                    {\r\n                        Definition = Cash { \r\n                            Direction = 1.0\r\n                            Price = stock.CurrentPrice\r\n                        }\r\n                        Pricing = None\r\n                    }\r\n            ]\r\n            Stock = stock\r\n        }\r\n\r\n    let cashPayOff strike ref = ref - strike\r\n\r\n    let condor stock = \r\n        let strike1 = floor(stock.CurrentPrice*0.6)\r\n        let strike2 = floor(stock.CurrentPrice*0.9)\r\n        let strike3 = floor stock.CurrentPrice*1.1\r\n        let strike4 = floor stock.CurrentPrice*1.4\r\n        {\r\n            Name = \"Condor\"\r\n            Legs = [ \r\n                    buildOptionLeg -1.0 strike2 expiry Call\r\n                    buildOptionLeg 1.0 strike1 expiry Call\r\n                    buildOptionLeg -1.0 strike3 expiry Call\r\n                    buildOptionLeg 1.0 strike4 expiry Call\r\n            ]\r\n            Stock = stock\r\n        }\r\n\r\n    let boxOption stock = \r\n        let strike1, strike2 = testStrikes stock\r\n        {\r\n            Name = \"Box Option\"\r\n            Legs = [ \r\n                    buildOptionLeg 1.0 strike1 expiry Call\r\n                    buildOptionLeg -1.0 strike2 expiry Call\r\n                    buildOptionLeg 1.0 strike2 expiry Call\r\n                    buildOptionLeg -1.0 strike1 expiry Call\r\n            ]\r\n            Stock = stock\r\n    }\r\n\r\n    let longCall stock = {\r\n        Name = \"Long Call - Out Of Money\"\r\n        Legs = [\r\n                buildOptionLeg 1.0 (stock.CurrentPrice*1.2) expiry Call\r\n        ]\r\n        Stock = stock\r\n    }\r\n\r\n    let shortCall stock = {\r\n        Name = \"Short Call - Out Of Money\"\r\n        Legs = [\r\n                buildOptionLeg -1.0 (stock.CurrentPrice*1.2) expiry Call\r\n        ]\r\n        Stock = stock\r\n    }\r\n\r\n    let callSpread stock = \r\n        let strike1,strike2 = testStrikes stock\r\n        {\r\n            Name = \"Bull Call Spread\"\r\n            Legs = [\r\n                    buildOptionLeg -1.0 strike2 expiry Call\r\n                    buildOptionLeg 1.0 strike1 expiry Call\r\n            ]\r\n            Stock = stock\r\n        }\r\n\r\n    let putSpread stock = \r\n        let strike1,strike2 = testStrikes stock\r\n        {\r\n            Name = \"Bull Put Spread\"\r\n            Legs = [\r\n                    buildOptionLeg -1.0 strike2 expiry Put\r\n                    buildOptionLeg 1.0 strike1 expiry Put\r\n            ]\r\n            Stock = stock\r\n        }\r\n\r\n    let strategiesForStock stock = [\r\n        longCall stock\r\n        shortCall stock\r\n        callSpread stock\r\n        putSpread stock\r\n        straddle stock\r\n        strangle stock\r\n        butterfly stock\r\n        riskReversal stock\r\n        collar stock\r\n        condor stock\r\n        boxOption stock\r\n        coveredCall stock\r\n    ]\r\n\r\n    let exampleStock = {\r\n        CurrentPrice = 100.0\r\n        Volatility = 0.05\r\n        Rate = 0.03\r\n    }\r\n    \r\n    let exampleStrategies = strategiesForStock exampleStock\r\n\r\n    let getStrategy name stock = \r\n        strategiesForStock stock |> Seq.find(fun s->s.Name = name)\r\n\n\n\n/** WEBPACK FOOTER **\n ** ../Pricer.Core/StrategiesExamples.fs\n **/","﻿namespace Pricer.Fabled\r\n\r\nopen System\r\nopen Fable.Core\r\nopen Fable.Import\r\nopen Fable.Import.Browser\r\nopen Pricer.Core\r\n\r\ntype Value = {\r\n    x: int\r\n    y: float\r\n}\r\n\r\ntype DateScatterValue = {\r\n    x: DateTime\r\n    y: float\r\n    size: float\r\n}\r\n\r\ntype Series<'a> = {\r\n    key: string\r\n    values: 'a array\r\n}\r\n\r\ntype Axis = \r\n    abstract axisLabel: string -> Axis\r\n    abstract tickFormat: System.Func<Object,string> -> Axis\r\n\r\nmodule DateUtils = \r\n    [<Emit(\"new Date($0)\")>]\r\n    let fromTicks (ticks: int): DateTime = jsNative\r\n\r\n[<AbstractClass>]\r\ntype Chart() = \r\n    abstract xAxis: Axis\r\n    abstract yAxis: Axis\r\n    abstract showLegend: bool -> Chart\r\n    abstract showXAxis: bool -> Chart\r\n    abstract showYAxis: bool -> Chart\r\n    abstract color: string[] -> Chart\r\n\r\n[<AbstractClass>]\r\ntype LineChart() = inherit Chart()\r\n        with member __.useInteractiveGuideline (value:bool): Chart = failwith \"JSOnly\"\r\n\r\n[<AbstractClass>]\r\ntype ScatterChart() = inherit Chart()\r\n    with member __.pointRange(value: double array): ScatterChart = failwith \"JSOnly\"\r\n\r\n        \r\ntype models = \r\n    abstract lineChart: unit -> LineChart\r\n    abstract scatterChart: unit -> ScatterChart\r\n\r\n[<Erase>]\r\nmodule nv =\r\n    let models: models = failwith \"JS only\"\r\n\r\nmodule Charting =\r\n \r\n    let tuplesToPoints (data: (float*float) list): Value array = \r\n            data |> List.map (fun (x,y) -> \r\n                {\r\n                    Value.x = int x\r\n                    Value.y = y\r\n                }\r\n            ) |> Array.ofList\r\n\r\n    let buildLines (data:(Leg*(float*float) list) seq)= \r\n        data |> Seq.map (fun (leg,linedata) -> \r\n            {\r\n                key = leg.Definition.Name\r\n                values = linedata |> tuplesToPoints\r\n            })\r\n\r\n    let prepareLineChart = \r\n        let chart = nv.models.lineChart().useInteractiveGuideline(true).showLegend(true).showXAxis(true)\r\n        chart.xAxis.axisLabel(\"Underlying Price\").tickFormat(D3.Globals.format(\",.1f\")) |> ignore\r\n        chart.yAxis.axisLabel(\"Profit\").tickFormat(D3.Globals.format(\",.1f\")) |> ignore\r\n        chart\r\n\r\n\r\n    let clearAndGetParentChartDiv (selector:string) =\r\n        let element = D3.Globals.select(selector);\r\n        element.html(\"\") |> ignore\r\n        element\r\n    \r\n    let drawChart (chart:Chart) (data: Object) (chartSelector: string) = \r\n        let chartElement = clearAndGetParentChartDiv(chartSelector)\r\n        chartElement.style(\"height\",\"500px\") |> ignore\r\n        chartElement.datum(data).call(chart) |> ignore\r\n\r\n\r\n    let drawLineChart (data: Series<Value> array) (chartSelector:string) =      \r\n        let chart = prepareLineChart\r\n        drawChart chart data chartSelector\r\n\r\n    let drawPayoff data =\r\n        let payoff = \r\n            match data with\r\n                | SingleYear (strategyData, legsData) ->\r\n                    let legLines = buildLines legsData\r\n                    let strategyLine = {\r\n                        key = \"Strategy\"\r\n                        values = strategyData |> tuplesToPoints\r\n                    }\r\n                        \r\n                    seq {\r\n                        yield! legLines\r\n                        yield strategyLine\r\n                    } |> Array.ofSeq\r\n                | _ -> failwith \"not implemented\"\r\n\r\n        drawLineChart payoff        \r\n\r\n    let legAndPricingToDataPoint (l,pricing) = \r\n        {\r\n            x = l.Expiry\r\n            y = l.Strike\r\n            size = pricing.Premium\r\n        }\r\n        \r\n    let drawScatter (data: Series<DateScatterValue> array) (chartSelector:string) = \r\n        let colors = D3.Scale.Globals.category10()\r\n        let chart = nv.models.scatterChart().pointRange([|10.0;800.0|]).showLegend(true).showXAxis(true).color(colors.range())\r\n        let timeFormat = D3.Time.Globals.format(\"%x\")\r\n        chart.yAxis.axisLabel(\"Strike\") |> ignore\r\n        chart.xAxis.tickFormat(fun x -> \r\n            let dateValue = DateUtils.fromTicks(x :?> int)\r\n            timeFormat.Invoke(dateValue)\r\n        ).axisLabel(\"Expiry\") |> ignore\r\n        drawChart chart data chartSelector\n\n\n/** WEBPACK FOOTER **\n ** ./Charting.fs\n **/","module.exports = d3;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"d3\"\n ** module id = 12\n ** module chunks = 0 1\n **/","﻿namespace Pricer.Fabled\n\nopen Fable.Core.JsInterop\nopen Fable.Core\nopen Fable.Import\n\n[<Erase>]\nmodule Lib =\n    let [<Global>] Vue: obj = failwith \"JS only\"\n    let [<Global>] Router: obj = failwith \"JS only\"\n\n// This helper uses JS reflection to convert a class instancegfa\n// to the options' format required by Vue\nmodule VueHelper =\n    let createFromObj(data: obj, extraOpts: obj) =\n        let methods = obj()\n        let computed = obj()\n        let proto = JS.Object.getPrototypeOf data\n        for k in JS.Object.getOwnPropertyNames proto do\n            let prop = JS.Object.getOwnPropertyDescriptor(proto, k)\n            match prop.value with\n            | Some f ->\n                methods?(k) <- f\n            | None ->\n                computed?(k) <- JsInterop.createObj [\n                    \"get\" ==> prop?get\n                    \"set\" ==> prop?set\n                ]\n        extraOpts?data <- data\n        extraOpts?computed <- computed\n        extraOpts?methods <- methods\n        JsInterop.createNew Lib.Vue extraOpts\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./VueHelpers.fs\n **/","﻿namespace Pricer.Core\r\n\r\nopen System\r\n\r\ntype PayoffsGenerator (pricer:IPricer) =\r\n\r\n    member this.legPricing stock leg =\r\n        match leg.Definition with\r\n            | Cash cashLeg -> pricer.priceCash cashLeg\r\n            | Option optionLeg -> pricer.priceOption stock optionLeg\r\n            | Convertible convertible -> pricer.priceConvert stock convertible\r\n\r\n    //only some x points are interesting - precisely all the strikes\r\n    member this.getInterestingPoints strategy =\r\n        if strategy.Legs |> Seq.isEmpty then Seq.empty\r\n        else\r\n            let strikes = strategy.Legs |> List.map (fun leg ->\r\n                match leg.Definition with\r\n                    | Cash cash -> cash.Price\r\n                    | Option option -> option.Strike\r\n                    | Convertible convertible -> convertible.ReferencePrice \r\n            )\r\n            let min = 0.5*(strikes |> Seq.min)\r\n            let max = 1.5*(strikes |> Seq.max)\r\n            seq {\r\n                yield min\r\n                yield! (strikes |> Seq.sort)\r\n                yield max\r\n            }\r\n    member this.legPayoff leg pricing (year:int) stockPrice =\r\n        match leg with\r\n\r\n            | Cash cashLeg -> cashLeg.Direction * (stockPrice - cashLeg.Price)\r\n            | Option optionLeg -> optionLeg.Direction * (BasicOptions.optionValue optionLeg stockPrice - pricing.Premium)\r\n            | Convertible convertible -> convertible.Direction * (float year * convertible.Coupon * convertible.FaceValue - pricing.Premium)\r\n\r\n\r\n    member this.getStrategyData (strategy:Strategy) =\r\n        let getLegPricing leg =\r\n            match leg.Pricing with\r\n                | Some pricing -> pricing\r\n                | None -> this.legPricing strategy.Stock leg\r\n\r\n        \r\n        let payOffsPerLeg = strategy.Legs |> Seq.map (fun leg ->\r\n            let pricing = getLegPricing leg\r\n            let pricedLeg = { leg with Pricing = Some pricing }\r\n            let payoffCalculator = this.legPayoff leg.Definition pricing   \r\n            pricedLeg, payoffCalculator\r\n        )\r\n\r\n        let interestingPoints = this.getInterestingPoints strategy\r\n        let hasConverts = strategy.Legs |> Seq.exists (fun leg -> match leg.Definition with | Convertible _ -> true | _ -> false)\r\n        \r\n        match hasConverts with\r\n            | true -> \r\n                let years = [1;2;3]\r\n\r\n                let legsData = payOffsPerLeg |> Seq.map (fun (leg,payOff) -> \r\n                    leg, years |> Seq.map (fun year -> [for stockPrice in interestingPoints  do yield stockPrice, payOff year stockPrice])\r\n                )\r\n\r\n                let strategyData = years |> Seq.map (fun year -> \r\n                    [for stockPrice in interestingPoints do yield stockPrice, payOffsPerLeg |> Seq.sumBy (fun (leg,payOff) -> payOff year stockPrice)]\r\n                )\r\n\r\n                MultiYear strategyData\r\n            | false -> \r\n                let legsData = payOffsPerLeg |> Seq.map (fun (leg,payOff) -> \r\n                    leg, [for stockPrice in interestingPoints  do yield stockPrice, payOff 1 stockPrice]\r\n                )\r\n\r\n                let strategyData = [for stockPrice in interestingPoints do yield stockPrice, payOffsPerLeg |> Seq.sumBy (fun (leg,payOff) -> payOff 1 stockPrice)]\r\n                \r\n                SingleYear (strategyData,legsData)\n\n\n/** WEBPACK FOOTER **\n ** ../Pricer.Core/PayoffsGenerator.fs\n **/","﻿namespace Pricer.Fabled\n\nopen System\nopen System.Text.RegularExpressions\n\nmodule Tools = \n    let parseDate exp = \n        let groups = Regex.Match(exp, @\"([0-9]+)-([0-9]+)\\-([0-9]+)\").Groups\n        let year = int groups.[1].Value\n        let month = int groups.[2].Value\n        let day = int groups.[3].Value\n        new DateTime(year, month, day)\n\n\n    let toDate (date:DateTime) = \n        sprintf \"%i-%02i-%02i\" date.Year date.Month date.Day\n\n\n/** WEBPACK FOOTER **\n ** ./Tools.fs\n **/"],"sourceRoot":""}